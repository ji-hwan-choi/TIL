# 멀티스레드와 동시성

## 1. 프로세스와 스레드

### 멀티태스킹과 멀티프로세싱

#### 단일 프로그램 실행

연산을 처리할 수 있는 CPU 코어가 1개만 있다고 가정 했을때, 초창기 컴퓨터는 한 번에 하나의 프로그램만 실행했다.  
예를들어, 음악을 들으며 워드 프로그램을 실행하고 싶지만 음악 프로그램이 끝나야 워드 프로그램 실행이 가능했다.  
이를 해결하기 위해 하나의 CPU 코어로 여러 프로그램을 동시에 실행하는 '멀티태스킹' 기술이 등장했다.

#### 멀티태스킹

현대의 CPU 는 초당 수십억 번 이상의 연산을 수행한다.
만약 CPU가 매우 빠르게 두 프로그램의 코드를 번갈아 수행한다면, 사람이 느낄 때 두 프로그램이 동시에 실행되는 것
처럼 느껴질 것이다. (대략 0.01초(10ms) 단위로 돌아가며 실행한다.)  
A 프로그램 0.01초 수행 -> B 프로그램 0.01초 수행 -> A프로그램 0.01초 수행  
사용자는 두 프로그램이 동시 실행 되는 것 같이 느낀다.  
이렇게 각 프로그램의 **실행 시간을 분할해서 마치 동시에 실행되는 것 처럼 하는 기법을 시분할(Time Sharing, 시간
공유) 기법**이라 한다.

> CPU에 어떤 프로그램이 얼마만큼 실행될지는 운영체제가 결정하는데 이것을 스케줄링(Scheduling)이라
> 한다. 이때 단순히 시간으로만 작업을 분할하지는 않고, CPU를 최대한 활용할 수 있는 다양한 우선순위와 최적화
> 기법을 사용한다.

#### 멀티프로세싱

컴퓨터 시스템에서 둘 이상의 프로세서(CPU 코어)를 사용하여 여러 작업을 동시
에 처리하는 기술을 의미한다. 멀티프로세싱 시스템은 하나의 CPU 코어만을 사용하는 시스템보다 동시에 더 많은 작업
을 처리할 수 있다.

#### 멀티프로세싱 vs. 멀티태스킹

멀티프로세싱은 하드웨어 장비의 관점이고, 멀티태스킹은 운영체제 소프트웨어의 관점이다.

- **멀티프로세싱**
  - **여러 CPU(여러 CPU 코어)를 사용**하여 동시에 여러 작업을 수행하는 것을 의미한다.
  - 하드웨어 기반으로 성능을 향상시킨다.
  - 예: 다중 코어 프로세서를 사용하는 현대 컴퓨터 시스템
- **멀티태스킹**
  - 단일 CPU(단일 CPU 코어)가 여러 작업을 동시에 수행하는 것처럼 보이게 하는 것을 의미한다.
  - 소프트웨어 기반으로 **CPU 시간을 분할하여 각 작업에 할당**한다.
  - 예: 현대 운영 체제에서 여러 애플리케이션이 동시에 실행되는 환경

---

### 프로세스와 스레드

- **프로세스**

  - 실행중인 프로그램
  - 각 프로세스는 독립적인 메모리 공간을 갖고 있으며, 운영체제에서 별도의 작업 단위로 분리해서 관리된다.
  - 하나의 프로세스가 충돌해도 다른 프로세스에는 영향을 미치지 않는다.

- **스레드**

  - 프로세스는 하나 이상의 스레드를 반드시 포함한다.
  - 스레드는 프로세스 내에서 실행되는 작업의 단위이다.
  - 한 프로세스 내에서 여러 스레드가 존재할 수 있으며, 이들은 **프로세스가 제공하는 동일한 메모리 공간을 공유**한다.
  - 스레드는 프로세스보다 단순하므로 생성 및 관리가 단순하고 가볍다.

- **단일 스레드**: 한 프로세스 내에 하나의 스레드만 존재
- **멀티 스레드**: 한 프로세스 내에 여러 스레드가 존재

#### 멀티스레드가 필요한 이유

- 워드 프로그램으로 문서를 편집하면서, 문서가 자동으로 저장되고, 맞춤법 검사도 함께 수행된다.
- 유튜브는 영상을 보는 동안, 댓글도 달 수 있다.

컨텍스트 스위칭은 CPU가 여러 스레드나 프로세스를 번갈아 실행할 때, 이전에 하던 작업의 상태(어디까지 했는지 등)를 저장하고 다음에 할 작업의 상태를 불러오는 과정이에요. 이 과정에서 약간의 시간이 소요되죠.
단일 코어에서 스레드가 너무 많으면 CPU가 스레드를 자주 바꿔가며 실행해야 해요. 이때 작업 상태를 저장하고 불러오는 컨텍스트 스위칭 비용이 커져서, 오히려 전체 성능이 떨어질 수 있답니다.

---

### 컨텍스트 스위칭

CPU 코어가 하나일 때 멀티태스킹은 여러 스레드를 번갈아가며 실행하는 방식으로 동작한다. 운영체제는 스레드를 잠시 멈출 때 현재 실행 상태(레지스터, 변수 값 등)를 메모리에 저장하고, 다른 스레드 실행 후 다시 불러온다.  
이렇게 문맥을 저장하고 복원하는 과정을 **컨텍스트 스위칭**이라 한다. 이 과정은 CPU 입장에서 추가 작업이 필요하기 때문에 성능 오버헤드가 발생한다.

### CPU-Bound 작업

- CPU 계산이 많은 작업 (예: 수학 연산, 영상 인코딩 등)
- CPU가 작업 속도를 결정
- 스레드 수 = CPU 코어 수 + 1 정도가 적절

### I/O-Bound 작업

- DB, 파일, 네트워크 등 외부 I/O가 많은 작업
- CPU는 대부분 대기 (I/O가 끝날 때까지)
- 스레드 수 = CPU 코어 수보다 훨씬 많이 생성 가능
  - CPU를 충분히 활용할 수 있는 수준까지 스레드 늘림
  - 단, 스레드가 너무 많으면 컨텍스트 스위칭 비용 발생 → 적절한 성능 테스트 필요

### 웹 서버 실무에서의 특징

- 대부분 I/O-Bound 작업 (DB 조회, 네트워크 통신 등)
- 요청 1개당 스레드 1개 사용
- CPU를 거의 사용하지 않으므로 코어 수보다 많은 스레드를 둬도 됨
- 무조건 좋은 서버를 쓰는 것보다 스레드 수 조정이 더 효과적

---

## 2. 스레드 생성과 실행

### 스레드 생성

#### 1. Thread 상속

```java
public class HelloThreadMain {

    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName() + ": main() start");

        HelloThread helloThread = new HelloThread();
        System.out.println(Thread.currentThread().getName() + ": start() 호출 전");
        helloThread.start();
        System.out.println(Thread.currentThread().getName() + ": start() 호출 후");

        System.out.println(Thread.currentThread().getName() + ": main() end");
    }

    static class HelloThread extends Thread {

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + ": run()");
        }
    }
}
```

#### 2. Runnable interface 구현

```java
public class HelloRunnableMain {

    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName() + ": main() start");

        HelloRunnable runnable = new HelloRunnable();
        Thread thread = new Thread(runnable);
        thread.start();

        System.out.println(Thread.currentThread().getName() + ": main() end");
    }

    static class HelloRunnable implements Runnable {

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + ": run()");
        }
    }
}
```

---

### start() vs run()

스레드의 `start()` 대신에 재정의한 `run()` 메서드를 직접 호출하면 어떻게 될까?

> `thread.run` 을 하면 Thread를 생성하는게 아닌, 그냥 해당 객체의 `run()` 메서드를 실행하는 것이다.

---

### 데몬 스레드

스레드는 사용자(user) 스레드와 데몬(daemon) 스레드 2가지 종류로 구분할 수 있다.

**사용자 스레드(non-daemon 스레드)**

- 프로그램의 주요 작업을 수행한다.
- 작업이 완료될 때까지 실행된다.
- 모든 user 스레드가 종료되면 JVM도 종료된다.

**데몬 스레드**

- 백그라운드에서 보조적인 작업을 수행한다.
- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.

JVM은 데몬 스레드의 실행 완료를 기다리지 않고 종료된다. 데몬 스레드가 아닌 모든 스레드가 종료되면, 자바 프로그
램도 종료된다.

```java
DaemonThread daemonThread = new DaemonThread();
daemonThread.setDaemon(true); // 데몬 스레드 여부
daemonThread.start();
```

- `setDaemon(true)` : 데몬 스레드로 설정한다.
- 데몬 스레드 여부는 `start()` 실행 전에 결정해야 한다. 이후에는 변경되지 않는다.
- 기본 값은 `false` 이다. (user 스레드가 기본)

### Thread 상속 vs Runnable 구현

**스레드 사용할 때는 `Thread` 를 상속 받는 방법보다 `Runnable` 인터페이스를 구현하는 방식을 사용하자.**

자바는 단일 상속만 가능하므로,`Thread` 를 상속 받으면, 다른 클래스를 상속 받을 수 없다.  
인터페이스 보다 유연성이 떨어진다.

`Runnable` 구현은 스레드와 실행할 작업을 분리하여 코드 가독성이 높고,  
여러 스레드가 동일한 `Runnable` 객체를 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.

---

## 3. 스레드 제어와 생명 주기 1

## 스레드 상태

**getState()**: 스레드의 현재 상태를 반환하는 메서드이다. 반환되는 값은 `Thread.State` 열거형에 정의된 상
수 중 하나이다. 주요 상태는 다음과 같다.

- **New (새로운 상태)**: 스레드가 생성되었으나 아직 시작되지 않은 상태.
- **Runnable (실행 가능 상태)**: 스레드가 실행 중이거나 실행될 준비가 된 상태.
- **일시 중지 상태들 (Suspended States)**
  - **Blocked (차단 상태)**: 스레드가 동기화 락을 기다리는 상태.
  - **Waiting (대기 상태)**: 스레드가 무기한으로 다른 스레드의 작업을 기다리는 상태.
  - **Timed Waiting (시간 제한 대기 상태)**: 스레드가 일정 시간 동안 다른 스레드의 작업을 기다리는 상태.
- **Terminated (종료 상태)**: 스레드의 실행이 완료된 상태.

```java
Thread thread = new Thread(new HelloRunnable(), "myThread");
thread.start();
System.out.println(thread.getState());
```

1. **New (새로운 상태)**

- 스레드가 생성되고 아직 시작되지 않은 상태이다.
- 이 상태에서는 `Thread` 객체가 생성되지만, `start()` 메서드가 호출되지 않은 상태이다.
- 예: `Thread thread = new Thread(runnable);

2. **Runnable (실행 가능 상태)**

- 스레드가 실행될 준비가 된 상태이다. 이 상태에서 스레드는 실제로 CPU에서 실행될 수 있다.
- `start()` 메서드가 호출되면 스레드는 이 상태로 들어간다.
- 예: `thread.start();`
- 실행 중이거나 실행 대기 중인 상태 (스케줄러의 실행 대기열에 포함된 상태)
- 운영체제 스케줄러의 실행 대기열에 있든, CPU에서 실제 실행되고 있든 모두 `RUNNABLE` 상태이
  다. 자바에서 둘을 구분해서 확인할 수는 없다.
- 보통 실행 상태라고 부른다.

3. **Blocked (차단 상태)**

- 스레드가 다른 스레드에 의해 동기화 락을 얻기 위해 기다리는 상태이다.
- 예를 들어, `synchronized` 블록에 진입하기 위해 락을 얻어야 하는 경우 이 상태에 들어간다.

4. **Waiting (대기 상태)**

- 스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태이다.
- `wait()` , `join()` 메서드가 호출될 때 이 상태가 된다.
- 스레드는 다른 스레드가 `notify()` 또는 `notifyAll()` 메서드를 호출하거나, `join()` 이 완료될 때 까지 기다린다.

5. **Timed Waiting (시간 제한 대기 상태)**

- 스레드가 특정 시간 동안 다른 스레드의 작업이 완료되기를 기다리는 상태이다.
- `sleep(long millis)` , `wait(long timeout)` , `join(long millis)` 메서드가 호출될 때 이 상태가 된다.

6. **Terminated (종료 상태)**

- 스레드의 실행이 완료된 상태이다.
- 스레드가 정상적으로 종료되거나, 예외가 발생하여 종료된 경우 이 상태로 들어간다.
- 스레드는 한 번 종료되면 다시 시작할 수 없다.

**자바 스레드의 상태 전이 과정**

1. **New → Runnable**: `start()` 메서드를 호출하면 스레드가 `Runnable` 상태로 전이된다.
2. **Runnable → Blocked/Waiting/Timed Waiting**: 스레드가 락을 얻지 못하거나, `wait()` 또는 `sleep()` 메서드를 호출할 때 해당 상태로 전이된다.
3. **Blocked/Waiting/Timed Waiting → Runnable**: 스레드가 락을 얻거나, 기다림이 완료되면 다시 `Runnable` 상태로 돌아간다.
4. **Runnable → Terminated**: 스레드의 `run()` 메서드가 완료되면 스레드는 `Terminated` 상태가 된다.

---

### 체크 예외 재정의

- **체크 예외**
  - 부모 메서드가 체크 예외를 던지지 않는 경우, 재정의된 자식 메서드도 체크 예외를 던질 수 없다.
  - 자식 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만 던질 수 있다.
- **언체크(런타임) 예외**
  - 예외 처리를 강제하지 않으므로 상관없이 던질 수 있다.

`Runnable` 인터페이스의 `run()` 메서드는 아무런 체크 예외를 던지지 않는다.  
따라서 `Runnable` 인터페이스의 `run()` 메서드를 재정의 하는 곳에서는 체크 예외를 밖으로 던질 수 없다.

> 부모 클래스의 메서드를 호출하는 클라이언트 코드는 부모 메서드가 던지는 특정 예외만을 처리하도록 작성된다.  
> 자식 클래스가 더 넓은 범위의 예외를 던지면 해당 코드는 모든 예외를 제대로 처리하지 못할 수 있다.  
> 이는 예외 처리의 일관성을 해치고, 예상하지 못한 런타임 오류를 초래할 수 있다.

```java
class Parent {
    void method() throws InterruptedException {
        // ...
    }
}

class Child extends Parent {
    @Override
    void method() throws Exception {
        // ...
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        try {
            p.method();
        } catch (InterruptedException e) {
            // InterruptedException 처리
        }
    }
}
```

- 자바 컴파일러는 `Parent p` 의 `method()` 를 호출한 것으로 인지한다.
- `Parent p` 는 `InterruptedException` 를 반환하는데, 그 자식이 전혀 다른 예외를 반환한다면 클라이언트는 해당 예외를 잡을 수 없다. 이것은 확실하게 모든 예외를 체크하는 체크 예외의 규약에 맞지 않는다.
- 따라서 자바에서 체크 예외의 메서드 재정의는 다음과 같은 규칙을 가진다.

**체크 예외 재정의 규칙**

- 자식 클래스에 재정의된 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만을 던질 수 있다.
- 원래 메서드가 체크 예외를 던지지 않는 경우, 재정의된 메서드도 체크 예외를 던질 수 없다.

---

## join

- `thread.join` 을 사용하면, 다른 스레드가 종료 될 떄 까지 기다린다.
  - `join()`을 호출한 스레드 A는 대상 스레드 B가 자신의 작업을 모두 마치고 종료될 때까지 실행을 멈추고 기다린다.
- `join()`은 대상 스레드가 끝날 때까지 무한히 기다리는 반면, `join(millis)`는 지정된 시간 동안만 기다린다. 시간 초과 시 기다림을 멈추고 다음 코드를 실행한다.

> `this` 는 호출된 인스턴스 메서드가 소속된 객체를 가리키는 참조이며, 이것이 스택 프레임 내부에 저장되어있다.

## 4. 스레드 제어와 생명 주기 2

### 인터럽트

자바 스레드 인터럽트란, 실행 중인 스레드를 강제로 종료하는 것이 아니라, 작업을 멈춰달라고 요청하는 **'협력적인 중단 신호'**이다.
신호를 받은 스레드가 스스로 현재 작업을 안전하게 마무리하고 종료하도록 유도하는 방식이다.

**인터럽트의 작동 원리**

- 인터럽트는 스레드 내부에 유지되는 '인터럽트 상태(interrupted status)'라는 불리언(`boolean`) 플래그를 통해 작동한다.

1. 인터럽트 요청: 다른 스레드가 특정 스레드의 `thread.interrupt()` 메서드를 호출합니다.
2. 상태 변경: `thread.interrupt()` 메서드가 호출된 스레드의 '인터럽트 상태' 플래그가 `true`로 설정됩니다.
3. 상태 확인 및 처리: 인터럽트 신호를 받은 스레드는 주기적으로 자신의 인터럽트 상태를 확인하고 그에 따른 처리를 수행합니다.

- **`Thread.currentThread().isInterrupted()`**

  - 해당 스레드의 '인터럽트 상태'를 반환한다.
  - 상태를 확인만 하고 변경하지는 않는다.

- **`Thread.interrupted()`**
  - 현재 스레드의 '인터럽트 상태'를 반환한 후, **그 상태를 false로 초기화**합니다.
  - 정적(static) 메서드이며, 호출하면 인터럽트 상태가 초기화된다는 점에 유의해야 한다.

> #### `InterruptedException` 예외
>
> 만약 스레드가 sleep(), wait(), join()과 같이 일시 정지(waiting) 상태에 있을 때 인터럽트가 걸리면, 즉시 InterruptedException 예외가 발생한다. 이 예외가 발생하면 스레드는 일시 정지 상태에서 즉시 깨어나 catch 블록의 코드를 실행하게 됩니다.
>
> 중요한 것은 InterruptedException이 발생하면, JVM이 자동으로 해당 스레드의 '인터럽트 상태'를 false로 초기화한다는 점이다.  
> 따라서 catch 블록에서 인터럽트 상태를 보존하고 싶다면, Thread.currentThread().interrupt()를 다시 호출하여 상태를 true로 설정해주어야 합니다.

### yield

현재 실행 중인 스레드가 자신에게 할당된 실행 시간(Time Slice)을 자발적으로 반납하여, 스레드 스케줄러가 자신과 동일한 우선순위를 가진 다른 스레드에게 실행 기회를 주도록 **제안(suggest)**하는 메서드이다.

> "나는 잠시 쉬어도 괜찮으니, 혹시 나와 같은 중요도(우선순위)를 가진 다른 스레드가 대기 중이라면 먼저 실행해"라고 운영체제(스케줄러)에 제안

- 강제성 없음: yield()를 호출해도 스케줄러가 이를 무시하고 해당 스레드를 계속 실행할 수 있습니다. 즉, 실행을 양보한다는 보장이 없다.
- 동일 우선순위: 자신보다 우선순위가 낮은 스레드에게는 양보하지 않는다.

> `Thread.yield()`는 Runnable 상태를 유지하며 잠깐 CPU 사용 기회를 양보하지만,  
> `Thread.sleep()`은 스레드를 Timed Waiting 상태로 완전히 옮겨 스케줄링에서 제외한다.
>
> - 모든 스레드가 쉬고있는데, `sleep()`을 하면 본인도 쉴 수 있지만, -`yield` 는 본인이라도 실행한다.
>
> Runnable 상태는 Running , Ready 두 상태가 있는데, 자바에선 두 상태를 구별하진 못한다.  
> `yield` Running 상태를 Ready로 바꾸는 것이다.

---

## 5. 메모리 가시성

멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 것을 메모리 가시성(memory visibility)이라 한다.  
이름 그대로 메모리에 변경한 값이 보이는가, 보이지 않는가의 문제이다.

```java
public class VolatileCountMain {

    public static void main(String[] args) {
        MyTask task = new MyTask();
        Thread t = new Thread(task, "work");
        t.start();

        sleep(1000);

        task.flag = false;
        log("flag = " + task.flag + ", count = " + task.count + " in main");
    }

    static class MyTask implements Runnable {
        //boolean flag = true;
        //long count;
        volatile boolean flag = true;
        volatile long count;

        @Override
        public void run() {
            while(flag) {
                count++;
                //1억번에 한번씩 출력
                if (count % 100_000_000 == 0) {
                    log("flag = " + flag + ", count = " + count + " in while()");
                }
            }
            log("flag = " + flag + ", count = " + count + " 종료");
        }
    }
}
```

```java
// 1번
boolean flag = true;
long count;

// 2번
volatile boolean flag = true;
volatile long count;
```

위 코드에서 1번 주석으로 코드를 실행하면, main 스레드에서 바꾼 flag값이 즉시 적용 되지 않는다.  
이유는 CPU는 성능을 위해 메인 메모리에 있는 데이터를 CPU 캐시 메모리에 저장하는데, **멀티코어 환경에서는 각 코어마다 별도의 캐시 메모리를 가지기 때문이다.**

이로 인해 다음과 같은 상황이 발생한다.

1.  **값 복사:** `work` 스레드를 실행하는 **CPU 1번 코어**는 `flag` 변수의 값(`true`)을 자신의 캐시 메모리로 복사해 와서 사용한다.
2.  **캐시 사용:** `while(flag)` 문은 성능을 위해 매번 메인 메모리까지 접근하지 않고, **빠른 1번 코어의 캐시에 저장된 `flag` 값**을 계속 읽어 연산을 수행한다.
3.  **다른 코어에서의 변경:** 잠시 후, `main` 스레드를 실행하는 **CPU 2번 코어**가 `flag` 값을 `false`로 변경한다. 이 변경 사항은 **일단 2번 코어의 캐시에 먼저 기록된다.**
4.  **가시성 문제 발생:** 2번 코어 캐시의 변경된 값이 메인 메모리에 즉시 반영된다는 보장이 없으며, 설령 반영되더라도 1번 코어는 이 사실을 모르고 **계속 자신의 캐시에 저장된 `true` 값을 바라보게 된다.** 그 결과 `work` 스레드는 `while`문을 빠져나오지 못하고 무한 루프에 빠지게 된다.

### `volatile` 키워드의 역할

이때 **`volatile` 키워드**를 사용하면 이 가시성 문제를 해결할 수 있다. 변수에 `volatile`을 붙이는 것은 컴파일러와 CPU에게 다음과 같이 약속하는 것과 같다.

- **값을 쓸 때 (Write):** 이 변수에 값을 쓰는 스레드는 CPU 캐시에만 값을 기록하지 말고, **즉시 메인 메모리까지 변경된 값을 전달(flush)해야 한다.**
- **값을 읽을 때 (Read):** 이 변수의 값을 읽는 스레드는 CPU 캐시에 저장된 값이 있더라도 이를 무시하고, **항상 메인 메모리에서 최신 값을 직접 가져와야 한다.**

결론적으로 `volatile`은 여러 스레드에서 공유되는 변수의 변경 사항이 특정 CPU의 캐시에만 머무르지 않고 즉시 메인 메모리에 반영되도록 강제하여, 다른 모든 스레드가 이 최신 값을 바라보도록 보장하는 역할을 한다. 이를 통해 **'메모리 가시성'을 확보하는 것이다.**
