# 멀티스레드와 동시성

## 1. 프로세스와 스레드

### 멀티태스킹과 멀티프로세싱

#### 단일 프로그램 실행

연산을 처리할 수 있는 CPU 코어가 1개만 있다고 가정 했을때, 초창기 컴퓨터는 한 번에 하나의 프로그램만 실행했다.  
예를들어, 음악을 들으며 워드 프로그램을 실행하고 싶지만 음악 프로그램이 끝나야 워드 프로그램 실행이 가능했다.  
이를 해결하기 위해 하나의 CPU 코어로 여러 프로그램을 동시에 실행하는 '멀티태스킹' 기술이 등장했다.

#### 멀티태스킹

현대의 CPU 는 초당 수십억 번 이상의 연산을 수행한다.
만약 CPU가 매우 빠르게 두 프로그램의 코드를 번갈아 수행한다면, 사람이 느낄 때 두 프로그램이 동시에 실행되는 것
처럼 느껴질 것이다. (대략 0.01초(10ms) 단위로 돌아가며 실행한다.)  
A 프로그램 0.01초 수행 -> B 프로그램 0.01초 수행 -> A프로그램 0.01초 수행  
사용자는 두 프로그램이 동시 실행 되는 것 같이 느낀다.  
이렇게 각 프로그램의 **실행 시간을 분할해서 마치 동시에 실행되는 것 처럼 하는 기법을 시분할(Time Sharing, 시간
공유) 기법**이라 한다.

> CPU에 어떤 프로그램이 얼마만큼 실행될지는 운영체제가 결정하는데 이것을 스케줄링(Scheduling)이라
> 한다. 이때 단순히 시간으로만 작업을 분할하지는 않고, CPU를 최대한 활용할 수 있는 다양한 우선순위와 최적화
> 기법을 사용한다.

#### 멀티프로세싱

컴퓨터 시스템에서 둘 이상의 프로세서(CPU 코어)를 사용하여 여러 작업을 동시
에 처리하는 기술을 의미한다. 멀티프로세싱 시스템은 하나의 CPU 코어만을 사용하는 시스템보다 동시에 더 많은 작업
을 처리할 수 있다.

#### 멀티프로세싱 vs. 멀티태스킹

멀티프로세싱은 하드웨어 장비의 관점이고, 멀티태스킹은 운영체제 소프트웨어의 관점이다.

- **멀티프로세싱**
  - **여러 CPU(여러 CPU 코어)를 사용**하여 동시에 여러 작업을 수행하는 것을 의미한다.
  - 하드웨어 기반으로 성능을 향상시킨다.
  - 예: 다중 코어 프로세서를 사용하는 현대 컴퓨터 시스템
- **멀티태스킹**
  - 단일 CPU(단일 CPU 코어)가 여러 작업을 동시에 수행하는 것처럼 보이게 하는 것을 의미한다.
  - 소프트웨어 기반으로 **CPU 시간을 분할하여 각 작업에 할당**한다.
  - 예: 현대 운영 체제에서 여러 애플리케이션이 동시에 실행되는 환경

---

### 프로세스와 스레드

- **프로세스**

  - 실행중인 프로그램
  - 각 프로세스는 독립적인 메모리 공간을 갖고 있으며, 운영체제에서 별도의 작업 단위로 분리해서 관리된다.
  - 하나의 프로세스가 충돌해도 다른 프로세스에는 영향을 미치지 않는다.

- **스레드**

  - 프로세스는 하나 이상의 스레드를 반드시 포함한다.
  - 스레드는 프로세스 내에서 실행되는 작업의 단위이다.
  - 한 프로세스 내에서 여러 스레드가 존재할 수 있으며, 이들은 **프로세스가 제공하는 동일한 메모리 공간을 공유**한다.
  - 스레드는 프로세스보다 단순하므로 생성 및 관리가 단순하고 가볍다.

- **단일 스레드**: 한 프로세스 내에 하나의 스레드만 존재
- **멀티 스레드**: 한 프로세스 내에 여러 스레드가 존재

#### 멀티스레드가 필요한 이유

- 워드 프로그램으로 문서를 편집하면서, 문서가 자동으로 저장되고, 맞춤법 검사도 함께 수행된다.
- 유튜브는 영상을 보는 동안, 댓글도 달 수 있다.

컨텍스트 스위칭은 CPU가 여러 스레드나 프로세스를 번갈아 실행할 때, 이전에 하던 작업의 상태(어디까지 했는지 등)를 저장하고 다음에 할 작업의 상태를 불러오는 과정이에요. 이 과정에서 약간의 시간이 소요되죠.
단일 코어에서 스레드가 너무 많으면 CPU가 스레드를 자주 바꿔가며 실행해야 해요. 이때 작업 상태를 저장하고 불러오는 컨텍스트 스위칭 비용이 커져서, 오히려 전체 성능이 떨어질 수 있답니다.

---

### 컨텍스트 스위칭

CPU 코어가 하나일 때 멀티태스킹은 여러 스레드를 번갈아가며 실행하는 방식으로 동작한다. 운영체제는 스레드를 잠시 멈출 때 현재 실행 상태(레지스터, 변수 값 등)를 메모리에 저장하고, 다른 스레드 실행 후 다시 불러온다.  
이렇게 문맥을 저장하고 복원하는 과정을 **컨텍스트 스위칭**이라 한다. 이 과정은 CPU 입장에서 추가 작업이 필요하기 때문에 성능 오버헤드가 발생한다.

### CPU-Bound 작업

- CPU 계산이 많은 작업 (예: 수학 연산, 영상 인코딩 등)
- CPU가 작업 속도를 결정
- 스레드 수 = CPU 코어 수 + 1 정도가 적절

### I/O-Bound 작업

- DB, 파일, 네트워크 등 외부 I/O가 많은 작업
- CPU는 대부분 대기 (I/O가 끝날 때까지)
- 스레드 수 = CPU 코어 수보다 훨씬 많이 생성 가능
  - CPU를 충분히 활용할 수 있는 수준까지 스레드 늘림
  - 단, 스레드가 너무 많으면 컨텍스트 스위칭 비용 발생 → 적절한 성능 테스트 필요

### 웹 서버 실무에서의 특징

- 대부분 I/O-Bound 작업 (DB 조회, 네트워크 통신 등)
- 요청 1개당 스레드 1개 사용
- CPU를 거의 사용하지 않으므로 코어 수보다 많은 스레드를 둬도 됨
- 무조건 좋은 서버를 쓰는 것보다 스레드 수 조정이 더 효과적

---

## 2. 스레드 생성과 실행

### 스레드 생성

#### 1. Thread 상속

```java
public class HelloThreadMain {

    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName() + ": main() start");

        HelloThread helloThread = new HelloThread();
        System.out.println(Thread.currentThread().getName() + ": start() 호출 전");
        helloThread.start();
        System.out.println(Thread.currentThread().getName() + ": start() 호출 후");

        System.out.println(Thread.currentThread().getName() + ": main() end");
    }

    static class HelloThread extends Thread {

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + ": run()");
        }
    }
}
```

#### 2. Runnable interface 구현

```java
public class HelloRunnableMain {

    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName() + ": main() start");

        HelloRunnable runnable = new HelloRunnable();
        Thread thread = new Thread(runnable);
        thread.start();

        System.out.println(Thread.currentThread().getName() + ": main() end");
    }

    static class HelloRunnable implements Runnable {

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + ": run()");
        }
    }
}
```

---

### start() vs run()

스레드의 `start()` 대신에 재정의한 `run()` 메서드를 직접 호출하면 어떻게 될까?

> `thread.run` 을 하면 Thread를 생성하는게 아닌, 그냥 해당 객체의 `run()` 메서드를 실행하는 것이다.

---

### 데몬 스레드

스레드는 사용자(user) 스레드와 데몬(daemon) 스레드 2가지 종류로 구분할 수 있다.

**사용자 스레드(non-daemon 스레드)**

- 프로그램의 주요 작업을 수행한다.
- 작업이 완료될 때까지 실행된다.
- 모든 user 스레드가 종료되면 JVM도 종료된다.

**데몬 스레드**

- 백그라운드에서 보조적인 작업을 수행한다.
- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.

JVM은 데몬 스레드의 실행 완료를 기다리지 않고 종료된다. 데몬 스레드가 아닌 모든 스레드가 종료되면, 자바 프로그
램도 종료된다.

```java
DaemonThread daemonThread = new DaemonThread();
daemonThread.setDaemon(true); // 데몬 스레드 여부
daemonThread.start();
```

- `setDaemon(true)` : 데몬 스레드로 설정한다.
- 데몬 스레드 여부는 `start()` 실행 전에 결정해야 한다. 이후에는 변경되지 않는다.
- 기본 값은 `false` 이다. (user 스레드가 기본)

### Thread 상속 vs Runnable 구현

**스레드 사용할 때는 `Thread` 를 상속 받는 방법보다 `Runnable` 인터페이스를 구현하는 방식을 사용하자.**

자바는 단일 상속만 가능하므로,`Thread` 를 상속 받으면, 다른 클래스를 상속 받을 수 없다.  
인터페이스 보다 유연성이 떨어진다.

`Runnable` 구현은 스레드와 실행할 작업을 분리하여 코드 가독성이 높고,  
여러 스레드가 동일한 `Runnable` 객체를 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.

---

## 3. 스레드 제어와 생명 주기 1

## 스레드 상태

**getState()**: 스레드의 현재 상태를 반환하는 메서드이다. 반환되는 값은 `Thread.State` 열거형에 정의된 상
수 중 하나이다. 주요 상태는 다음과 같다.

- **New (새로운 상태)**: 스레드가 생성되었으나 아직 시작되지 않은 상태.
- **Runnable (실행 가능 상태)**: 스레드가 실행 중이거나 실행될 준비가 된 상태.
- **일시 중지 상태들 (Suspended States)**
  - **Blocked (차단 상태)**: 스레드가 동기화 락을 기다리는 상태.
  - **Waiting (대기 상태)**: 스레드가 무기한으로 다른 스레드의 작업을 기다리는 상태.
  - **Timed Waiting (시간 제한 대기 상태)**: 스레드가 일정 시간 동안 다른 스레드의 작업을 기다리는 상태.
- **Terminated (종료 상태)**: 스레드의 실행이 완료된 상태.

```java
Thread thread = new Thread(new HelloRunnable(), "myThread");
thread.start();
System.out.println(thread.getState());
```

1. **New (새로운 상태)**

- 스레드가 생성되고 아직 시작되지 않은 상태이다.
- 이 상태에서는 `Thread` 객체가 생성되지만, `start()` 메서드가 호출되지 않은 상태이다.
- 예: `Thread thread = new Thread(runnable);

2. **Runnable (실행 가능 상태)**

- 스레드가 실행될 준비가 된 상태이다. 이 상태에서 스레드는 실제로 CPU에서 실행될 수 있다.
- `start()` 메서드가 호출되면 스레드는 이 상태로 들어간다.
- 예: `thread.start();`
- 실행 중이거나 실행 대기 중인 상태 (스케줄러의 실행 대기열에 포함된 상태)
- 운영체제 스케줄러의 실행 대기열에 있든, CPU에서 실제 실행되고 있든 모두 `RUNNABLE` 상태이
  다. 자바에서 둘을 구분해서 확인할 수는 없다.
- 보통 실행 상태라고 부른다.

3. **Blocked (차단 상태)**

- 스레드가 다른 스레드에 의해 동기화 락을 얻기 위해 기다리는 상태이다.
- 예를 들어, `synchronized` 블록에 진입하기 위해 락을 얻어야 하는 경우 이 상태에 들어간다.

4. **Waiting (대기 상태)**

- 스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태이다.
- `wait()` , `join()` 메서드가 호출될 때 이 상태가 된다.
- 스레드는 다른 스레드가 `notify()` 또는 `notifyAll()` 메서드를 호출하거나, `join()` 이 완료될 때 까지 기다린다.

5. **Timed Waiting (시간 제한 대기 상태)**

- 스레드가 특정 시간 동안 다른 스레드의 작업이 완료되기를 기다리는 상태이다.
- `sleep(long millis)` , `wait(long timeout)` , `join(long millis)` 메서드가 호출될 때 이 상태가 된다.

6. **Terminated (종료 상태)**

- 스레드의 실행이 완료된 상태이다.
- 스레드가 정상적으로 종료되거나, 예외가 발생하여 종료된 경우 이 상태로 들어간다.
- 스레드는 한 번 종료되면 다시 시작할 수 없다.

**자바 스레드의 상태 전이 과정**

1. **New → Runnable**: `start()` 메서드를 호출하면 스레드가 `Runnable` 상태로 전이된다.
2. **Runnable → Blocked/Waiting/Timed Waiting**: 스레드가 락을 얻지 못하거나, `wait()` 또는 `sleep()` 메서드를 호출할 때 해당 상태로 전이된다.
3. **Blocked/Waiting/Timed Waiting → Runnable**: 스레드가 락을 얻거나, 기다림이 완료되면 다시 `Runnable` 상태로 돌아간다.
4. **Runnable → Terminated**: 스레드의 `run()` 메서드가 완료되면 스레드는 `Terminated` 상태가 된다.

## 체크 예외 재정의

- **체크 예외**
  - 부모 메서드가 체크 예외를 던지지 않는 경우, 재정의된 자식 메서드도 체크 예외를 던질 수 없다.
  - 자식 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만 던질 수 있다.
- **언체크(런타임) 예외**
  - 예외 처리를 강제하지 않으므로 상관없이 던질 수 있다.

`Runnable` 인터페이스의 `run()` 메서드는 아무런 체크 예외를 던지지 않는다.  
따라서 `Runnable` 인터페이스의 `run()` 메서드를 재정의 하는 곳에서는 체크 예외를 밖으로 던질 수 없다.

> 부모 클래스의 메서드를 호출하는 클라이언트 코드는 부모 메서드가 던지는 특정 예외만을 처리하도록 작성된다.  
> 자식 클래스가 더 넓은 범위의 예외를 던지면 해당 코드는 모든 예외를 제대로 처리하지 못할 수 있다.  
> 이는 예외 처리의 일관성을 해치고, 예상하지 못한 런타임 오류를 초래할 수 있다.

```java
class Parent {
    void method() throws InterruptedException {
        // ...
    }
}

class Child extends Parent {
    @Override
    void method() throws Exception {
        // ...
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        try {
            p.method();
        } catch (InterruptedException e) {
            // InterruptedException 처리
        }
    }
}
```

- 자바 컴파일러는 `Parent p` 의 `method()` 를 호출한 것으로 인지한다.
- `Parent p` 는 `InterruptedException` 를 반환하는데, 그 자식이 전혀 다른 예외를 반환한다면 클라이언트는 해당 예외를 잡을 수 없다. 이것은 확실하게 모든 예외를 체크하는 체크 예외의 규약에 맞지 않는다.
- 따라서 자바에서 체크 예외의 메서드 재정의는 다음과 같은 규칙을 가진다.

**체크 예외 재정의 규칙**

- 자식 클래스에 재정의된 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만을 던질 수 있다.
- 원래 메서드가 체크 예외를 던지지 않는 경우, 재정의된 메서드도 체크 예외를 던질 수 없다.

## join

- `thread.join` 을 사용하면, 다른 스레드가 종료 될 떄 까지 기다린다.
  - `join()`을 호출한 스레드 A는 대상 스레드 B가 자신의 작업을 모두 마치고 종료될 때까지 실행을 멈추고 기다린다.
- `join()`은 대상 스레드가 끝날 때까지 무한히 기다리는 반면, `join(millis)`는 지정된 시간 동안만 기다린다. 시간 초과 시 기다림을 멈추고 다음 코드를 실행한다.

> `this` 는 호출된 인스턴스 메서드가 소속된 객체를 가리키는 참조이며, 이것이 스택 프레임 내부에 저장되어있다.
