JPA 1:1 연관관계에서 mappedBy 쪽은 fetch = FetchType.EAGER 가 기본 설정이다.  
연관관계 주인 : Auction  
mappedBy : Item  
이와 같을때

```java
Auction auction = auciton.findByItemId();
Item item = auction.getItem();
```

위 코드는 `auction.getItem();` 할 때 item 테이블을 join해서 가져온다.

---

`@EntityGraph` 를 사용하면 left join해서 값을 가져온다.

```java
@Override
@EntityGraph(attributePaths = {"auction"}) // left join 설정
Optional<Item> findById(@NonNull Long id);
```

---

`@Async` 어노테이션을 사용해서 다른 스레드로 작업을 처리하려면, 같은 클래스의 메서드를 호출해선 안된다.

---

`Objects.equals(a, b)` vs `a.equals(b)`  
가장 큰 차이 = NPE 안전성  
`Objects.equals(a, b)` → 둘 중 하나가 null이어도 NPE 없이 비교(a가 null이면 그냥 false, 둘 다 null이면 true).  
`a.equals(b)` → a가 null이면 NPE.  
그래서 JPA ID처럼 nullable 가능성 있으면 Objects.equals가 안전

---

`anyMatch`

- 스트림에서 조건을 만족하는 요소가 하나라도 있으면 true.
- 단락 평가(short-circuit): 첫 매치에서 바로 멈춤 → 빠름.
- 반환: boolean (끝나는 터미널 연산)

```java
boolean hasBid = bids.stream()
   .anyMatch(b -> Objects.equals(b.getUser().getId(), userId));
```

---

### jpa `save()`

예를들어 BID 테이블을 Insert 시 auction_id 가 필요할 경우, 아래와 같이 사용해야 한다.

```java
repository.save(Bid.builder()
         .col1()
         .col2()
         .col3()
         // .auction(Auction.builder().id(auctionId).build())
         .auction(auctionRepository.getReferenceById(auctionId))
)
```

주석 처럼 사용할 경우, 영속성 컨테이너가 모르는 객체를 사용하려 해서 에러를 발생시킨다.  
혹은 이미 Auction 객체를 findBy 해왔을 경우 해당 auction 객체를 넣어주어야 한다.  
만약 Bid entity에 auction 필드에 대해 cascade 옵션이 걸려 있을때 주석 처럼 사용하면 Auction 테이블에 Insert를 먼저 실행한다.

---
