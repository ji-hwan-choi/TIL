- 제네릭을 사용하는 이유는 다양한 타입을 하나의 코드로 처리할 수 있어 코드 재사용성을 높일 수 있기 때문이다.  
  또한 사용되는 타입을 명확하게 지정할 수 있어 잘못된 타입 사용으로 인한 오류를 컴파일 시점에 방지할 수 있으며, 형변환 없이도 안전하게 객체를 다룰 수 있어 코드가 간결하고 안전해진다.  
  특히 컬렉션 사용 시 유용하며, 런타임 오류 가능성을 줄이고 유지보수성을 높이는 데에 도움이 된다.

용어 정리

- 제네릭(Generic) 단어
  - 제네릭이라는 단어는 일반적인, 범용적인이라는 영어 단어 뜻이다.
  - 풀어보면 특정 타입에 속한 것이 아니라 일반적으로, 범용적으로 사용할 수 있다는 뜻이다.
- 제네릭 타입 (Generic Type)클래스나 인터페이스를 정의할 때 타입 매개변수를 사용하는 것을 말한다.
  - 제네릭 클래스, 제네릭 인터페이스를 모두 합쳐서 제네릭 타입이라 한다.
  - 타입은 클래스, 인터페이스, 기본형(int 등)을 모두 합쳐서 부르는 말이다.
  - 예: class GenericBox<T> { private T t; }
  - 여기에서 GenericBox<T> 를 제네릭 타입이라 한다.
- 타입 매개변수 (Type Parameter)
  - 제네릭 타입이나 메서드에서 사용되는 변수로, 실제 타입으로 대체된다.
  - 예: GenericBox<T>
  - 여기에서 T 를 타입 매개변수라 한다.
- 타입 인자 (Type Argument)

  - 제네릭 타입을 사용할 때 제공되는 실제 타입이다.
  - 예: GenericBox<Integer>
  - 여기에서 Integer 를 타입 인자라 한다.

- 제네릭 명명 관례

  - 타입 매개변수는 일반적인 변수명처럼 소문자로 사용해도 문제는 없다.  
    하지만 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례를 따른다.  
    주로 사용하는 키워드는 다음과 같다.
    - E - Element
    - K - Key
    - N - Number
    - T - Type
    - V - Value
    - S,U,V etc. - 2nd, 3rd, 4th types

- **타입 인자로 기본형은 사용할 수 없다.**
  - 제네릭의 타입 인자로 기본형(int , double ..)은 사용할 수 없다. 대신에 래퍼 클래스(Integer , Double )를 사용하면 된다.

> 제네릭 타입을 사용할 때는 항상 `<>` 를 사용해서 사용시점에 원하는 타입을 지정해야 한다.  
> 그런데 아래와 같이 `<>` 을 지정하지 않을 수 있는데, 이런 것을 로 타입(raw type), 또는 원시 타입이라한다.  
> `GenericBox integerBox = new GenericBox();`  
> 원시 타입을 사용하면 내부의 타입 매개변수가 Object 로 사용된다고 이해하면 된다.  
> 제네릭 타입을 사용할 때는 항상 `<>` 를 사용해서 사용시점에 타입을 지정해야 한다. 그런데 왜 이런 로 타입을 지원하는것일까?  
> 자바의 제네릭이 자바가 처음 등장할 때 부터 있었던 것이 아니라 자바가 오랜기간 사용된 이후에 등장했기 때문에 제네릭이 없던 시절의 과거 >코드와의 하위 호환이 필요했다.  
> 그래서 어쩔 수 없이 이런 로 타입을 지원한다.  
> 정리하면 로 타입을 사용하지 않아야 한다.  
> 만약에 Object 타입을 사용해야 한다면 다음과 같이 타입 인자로 Object 를 지정해서 사용하면 된다.

- `<T extends Animal>`

  - T에 들어올 수 있는 타입은 Animal만 가능하다.  
    **제네릭에 타입 매개변수 상한**을 사용해서 타입 안전성을 지키면서 상위 타입의 원하는 기능까지 사용할 수 있었다.  
    덕분에 코드 재사용과 타입 안전성이라는 두 마리 토끼를 동시에 잡을 수 있었다.

- 제네릭 메서드

  - 정의: `public static <T> T genericMethod(T t) {}`
  - 타입 인자 전달: 메서드를 호출하는 시점
    - 예) `GenericMethod.<Integer>genericMethod(i)`
  - 제네릭 메서드는 클래스 전체가 아니라 특정 메서드 단위로 제네릭을 도입할 때 사용한다.
  - 제네릭 메서드를 정의할 때는 메서드의 반환 타입 왼쪽에 다이아몬드를 사용해서 `<T>` 와 같이 타입 매개변수를 적어준다.
  - 제네릭 메서드는 메서드를 실제 호출하는 시점에 다이아몬드를 사용해서 `<Integer>` 와 같이 타입을 정하고 호출한다.
    - 제네릭 메서드는 클래스 레벨과 달리, 메서드를 실제로 호출하는 시점에 전달되는 인자를 보고 타입이 결정된다.

- 제네릭 타입
  - 정의: `GenericClass<T>`
  - 타입 인자 전달: 객체를 생성하는 시점
    - 예) `new GenericClass<String>`

> **참고!**  
> 제네릭 타입은 `static` 메서드에 타입 매개변수를 사용할 수 없다. 제네릭 타입은 객체를 생성하는 시점에 타입이 정해진다.  
> 그런데 `static` 메서드는 인스턴스 단위가 아니라 클래스 단위로 작동하기 때문에 제네릭 타입과는 무관하다.  
> 따라서 `static` 메서드에 제네릭을 도입하려면 제네릭 메서드를 사용해야 한다.
>
> ```
> class Box<T> {
>   T instanceMethod(T t) {} //가능
>   static T staticMethod1(T t) {} //제네릭 타입의 T 사용 불가능
> }
> ```

- **제네릭 타입과 제네릭 메서드의 우선순위**

  - **정적 메서드는 제네릭 메서드만** 적용할 수 있지만, **인스턴스 메서드는 제네릭 타입도 제네릭 메서드도 둘다** 적용할 수 있다.
  - 제네릭 타입 설정
    - `class ComplexBox<T extends Animal>`
  - 제네릭 메서드 설정
    - `<T> T printAndReturn(T t)`
  - 제네릭 타입보다 제네릭 메서드가 높은 우선순위를 가진다.

  ```
    public class ComplexBox<T extends Animal> {
      private T animal;
      public void set(T animal) {
        this.animal = animal;
      }
      public <T> T printAndReturn(T t) {
        System.out.println("animal.className: " + animal.getClass().getName());
        System.out.println("t.className: " + t.getClass().getName());
        // t.getName(); // 호출 불가 메서드는 <T> 타입이다. <T extends Animal> 타입이 아니다.
      return t;
      }
    }
  ```

  - 따라서 `printAndReturn()` 은 제네릭 타입과는 무관하고 제네릭 메서드가 적용된다.
  - 프로그래밍에서 이렇게 모호한 것은 좋지 않다.  
    둘의 이름(제네릭 타입T , Z)이 겹치면 다음과 같이 둘 중 하나를 다른 이름으로 변경하는 것이 좋다.

- **제네릭 와일드 카드**

  - 와일드카드는 `?` 를 사용해서 정의한다. (`Box<?> box`)
  - 와일드카드는 제네릭 타입이나, 제네릭 메서드를 선언하는 것이 아니다.  
    **와일드카드는 이미 만들어진 제네릭 타입을 활용할 때 사용한다.**

  - 와일드 카드와 제네릭 메서드는 쓰임새가 비슷해 보일 수 있지만, **보다 단순하고 유연하게 사용할 수 있는 와일드 카드를 우선 사용하는 것이 유리**하다.  
    다만, **정확한 타입으로 값을 반환해야 하는 경우**에는 와일드 카드를 사용할 수 없기 때문에, 이럴 때는 **제네릭 메서드를 사용**하는 것이 적절하다.

- **상한 와일드카드**
  - `<? extends Animal>`
  - `Animal` 과 그 하위 타입만 입력 받는다. 만약 다른 타입을 입력하면 컴파일 오류가 발생한다.
- 하한 와일드카드

  - `<? super Animal>`
  - `?` 가 `Animal` 타입을 포함한 `Animal` 타입의 상위 타입만 입력 받을 수 있다는 뜻이다.

- 와일드카드는 주로 이미 정의된 제네릭 타입의 객체를 메서드 인자 등으로 받을 때, 유연하게 타입을 표현하기 위해 사용된니다.  
  선언이 아니다!

<br/>

- **배열의 특징**

  - 배열에서 자료를 찾을 때 인덱스(index)를 사용하면 매우 빠르게 자료를 찾을 수 있다.
    - 인덱스를 통한 입력, 변경, 조회의 경우 한번의 계산으로 자료의 위치를 찾을 수 있다.
    - `arr[2]` 에 위치한 자료를 찾는다고 가정해보자.
    - 배열은 메모리상에 순서대로 붙어서 존재한다.
    - `int` 는 `4byte` 를 차지한다.
    - 따라서 배열의 **시작 위치**인 x100 부터 시작해서 자료의 크기(4byte)와 **인덱스 번호를 곱하면 원하는 메모리 위치를 찾을 수 있다.**
    - 배열의 시작 참조(x100) + (자료의 크기(4byte) \* 인덱스 위치(2)) = x108이 나온다. 여기에는 숫자 10이 들어있다.
  - **간단 정리**
    - 공식: `배열의 시작 참조 + (자료의 크기 * 인덱스 위치)`
    - `arr[0]: x100 + (4byte * 0): x100`
    - `arr[1]: x100 + (4byte * 1): x104`
    - `arr[2]: x100 + (4byte * 2): x108`

- **시간 복잡도와 실제 성능**

  - 이론적으로 `LinkedList`의 중간 삽입 연산은 `ArrayList`보다 빠를 수 있다.  
    그러나 실제 성능은 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에 의해 영향을 받는다.
  - 추가로 `ArrayList`는 데이터를 한 칸씩 직접 이동하지 않고, 대신에 메모리 고속 복사를 사용한다.
  - `ArrayList`는 요소들이 메모리 상에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.
  - 반면, `LinkedList`는 각 요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느려질 수 있다.
  - `ArrayList`의 경우 CAPACITY를 넘어서면 배열을 다시 만들고 복사하는 과정이 추가된다. 하지만 한번에 50%씩 늘어나기 때문에 이 과정은 가끔 발생하므로, 전체 성능에 큰 영향을 주지는 않는다.
  - **정리하면 이론적으로 LinkedList가 중간 삽입에 있어 더 효율적일 수 있지만, 현대 컴퓨터 시스템의 메모리 접근 패턴, CPU 캐시 최적화, 메모리 고속 복사 등을 고려할 때 ArrayList가 실제 사용 환경에서 더 나은 성능을 보여주는 경우가 많다.**

- **배열 리스트 vs 연결 리스트**

  - 대부분의 경우 배열 리스트가 성능상 유리하다. 이런 이유로 실무에서는 주로 배열 리스트를 기본으로 사용한다.
  - 만약 데이터를 앞쪽에서 자주 추가하거나 삭제할 일이 있다면 연결 리스트를 고려하자.

- **Set**
  - 중복을 허용하지 않고, 순서를 보장하지 않는 자료 구조이다.
  - 특징:
    - 유일성: **셋에는 중복된 요소가 존재하지 않는다.** 셋에 요소를 추가할 때, 이미 존재하는 요소면 무시된다.
    - 순서 미보장: 대부분의 셋 구현에서는 요소들의 **순서를 보장하지 않는다.** 즉, 요소를 출력할 때 입력 순서와 다를 수 있다.
    - **빠른 검색**: 셋은 요소의 유무를 빠르게 확인할 수 있도록 최적화되어 있다. 이는 데이터의 중복을 방지하고 빠른 조회를 가능하게 한다.
