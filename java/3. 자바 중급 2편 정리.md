- 제네릭을 사용하는 이유는 다양한 타입을 하나의 코드로 처리할 수 있어 코드 재사용성을 높일 수 있기 때문이다.  
  또한 사용되는 타입을 명확하게 지정할 수 있어 잘못된 타입 사용으로 인한 오류를 컴파일 시점에 방지할 수 있으며, 형변환 없이도 안전하게 객체를 다룰 수 있어 코드가 간결하고 안전해진다.  
  특히 컬렉션 사용 시 유용하며, 런타임 오류 가능성을 줄이고 유지보수성을 높이는 데에 도움이 된다.

용어 정리

- 제네릭(Generic) 단어
  - 제네릭이라는 단어는 일반적인, 범용적인이라는 영어 단어 뜻이다.
  - 풀어보면 특정 타입에 속한 것이 아니라 일반적으로, 범용적으로 사용할 수 있다는 뜻이다.
- 제네릭 타입 (Generic Type)클래스나 인터페이스를 정의할 때 타입 매개변수를 사용하는 것을 말한다.
  - 제네릭 클래스, 제네릭 인터페이스를 모두 합쳐서 제네릭 타입이라 한다.
  - 타입은 클래스, 인터페이스, 기본형(int 등)을 모두 합쳐서 부르는 말이다.
  - 예: class GenericBox<T> { private T t; }
  - 여기에서 GenericBox<T> 를 제네릭 타입이라 한다.
- 타입 매개변수 (Type Parameter)
  - 제네릭 타입이나 메서드에서 사용되는 변수로, 실제 타입으로 대체된다.
  - 예: GenericBox<T>
  - 여기에서 T 를 타입 매개변수라 한다.
- 타입 인자 (Type Argument)

  - 제네릭 타입을 사용할 때 제공되는 실제 타입이다.
  - 예: GenericBox<Integer>
  - 여기에서 Integer 를 타입 인자라 한다.

- 제네릭 명명 관례

  - 타입 매개변수는 일반적인 변수명처럼 소문자로 사용해도 문제는 없다.  
    하지만 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례를 따른다.  
    주로 사용하는 키워드는 다음과 같다.
    - E - Element
    - K - Key
    - N - Number
    - T - Type
    - V - Value
    - S,U,V etc. - 2nd, 3rd, 4th types

- **타입 인자로 기본형은 사용할 수 없다.**
  - 제네릭의 타입 인자로 기본형(int , double ..)은 사용할 수 없다. 대신에 래퍼 클래스(Integer , Double )를 사용하면 된다.

> 제네릭 타입을 사용할 때는 항상 `<>` 를 사용해서 사용시점에 원하는 타입을 지정해야 한다.  
> 그런데 아래와 같이 `<>` 을 지정하지 않을 수 있는데, 이런 것을 로 타입(raw type), 또는 원시 타입이라한다.  
> `GenericBox integerBox = new GenericBox();`  
> 원시 타입을 사용하면 내부의 타입 매개변수가 Object 로 사용된다고 이해하면 된다.  
> 제네릭 타입을 사용할 때는 항상 `<>` 를 사용해서 사용시점에 타입을 지정해야 한다. 그런데 왜 이런 로 타입을 지원하는것일까?  
> 자바의 제네릭이 자바가 처음 등장할 때 부터 있었던 것이 아니라 자바가 오랜기간 사용된 이후에 등장했기 때문에 제네릭이 없던 시절의 과거 >코드와의 하위 호환이 필요했다.  
> 그래서 어쩔 수 없이 이런 로 타입을 지원한다.  
> 정리하면 로 타입을 사용하지 않아야 한다.  
> 만약에 Object 타입을 사용해야 한다면 다음과 같이 타입 인자로 Object 를 지정해서 사용하면 된다.

- `<T extends Animal>`

  - T에 들어올 수 있는 타입은 Animal만 가능하다.  
    **제네릭에 타입 매개변수 상한**을 사용해서 타입 안전성을 지키면서 상위 타입의 원하는 기능까지 사용할 수 있었다.  
    덕분에 코드 재사용과 타입 안전성이라는 두 마리 토끼를 동시에 잡을 수 있었다.

- 제네릭 메서드

  - 정의: `public static <T> T genericMethod(T t) {}`
  - 타입 인자 전달: 메서드를 호출하는 시점
    - 예) `GenericMethod.<Integer>genericMethod(i)`
  - 제네릭 메서드는 클래스 전체가 아니라 특정 메서드 단위로 제네릭을 도입할 때 사용한다.
  - 제네릭 메서드를 정의할 때는 메서드의 반환 타입 왼쪽에 다이아몬드를 사용해서 `<T>` 와 같이 타입 매개변수를 적어준다.
  - 제네릭 메서드는 메서드를 실제 호출하는 시점에 다이아몬드를 사용해서 `<Integer>` 와 같이 타입을 정하고 호출한다.
    - 제네릭 메서드는 클래스 레벨과 달리, 메서드를 실제로 호출하는 시점에 전달되는 인자를 보고 타입이 결정된다.

- 제네릭 타입
  - 정의: `GenericClass<T>`
  - 타입 인자 전달: 객체를 생성하는 시점
    - 예) `new GenericClass<String>`

> **참고!**  
> 제네릭 타입은 `static` 메서드에 타입 매개변수를 사용할 수 없다. 제네릭 타입은 객체를 생성하는 시점에 타입이 정해진다.  
> 그런데 `static` 메서드는 인스턴스 단위가 아니라 클래스 단위로 작동하기 때문에 제네릭 타입과는 무관하다.  
> 따라서 `static` 메서드에 제네릭을 도입하려면 제네릭 메서드를 사용해야 한다.
>
> ```
> class Box<T> {
>   T instanceMethod(T t) {} //가능
>   static T staticMethod1(T t) {} //제네릭 타입의 T 사용 불가능
> }
> ```

- **제네릭 타입과 제네릭 메서드의 우선순위**

  - **정적 메서드는 제네릭 메서드만** 적용할 수 있지만, **인스턴스 메서드는 제네릭 타입도 제네릭 메서드도 둘다** 적용할 수 있다.
  - 제네릭 타입 설정
    - `class ComplexBox<T extends Animal>`
  - 제네릭 메서드 설정
    - `<T> T printAndReturn(T t)`
  - 제네릭 타입보다 제네릭 메서드가 높은 우선순위를 가진다.

  ```
    public class ComplexBox<T extends Animal> {
      private T animal;
      public void set(T animal) {
        this.animal = animal;
      }
      public <T> T printAndReturn(T t) {
        System.out.println("animal.className: " + animal.getClass().getName());
        System.out.println("t.className: " + t.getClass().getName());
        // t.getName(); // 호출 불가 메서드는 <T> 타입이다. <T extends Animal> 타입이 아니다.
      return t;
      }
    }
  ```

  - 따라서 `printAndReturn()` 은 제네릭 타입과는 무관하고 제네릭 메서드가 적용된다.
  - 프로그래밍에서 이렇게 모호한 것은 좋지 않다.  
    둘의 이름(제네릭 타입T , Z)이 겹치면 다음과 같이 둘 중 하나를 다른 이름으로 변경하는 것이 좋다.

- **제네릭 와일드 카드**

  - 와일드카드는 `?` 를 사용해서 정의한다. (`Box<?> box`)
  - 와일드카드는 제네릭 타입이나, 제네릭 메서드를 선언하는 것이 아니다.  
    **와일드카드는 이미 만들어진 제네릭 타입을 활용할 때 사용한다.**

  - 와일드 카드와 제네릭 메서드는 쓰임새가 비슷해 보일 수 있지만, **보다 단순하고 유연하게 사용할 수 있는 와일드 카드를 우선 사용하는 것이 유리**하다.  
    다만, **정확한 타입으로 값을 반환해야 하는 경우**에는 와일드 카드를 사용할 수 없기 때문에, 이럴 때는 **제네릭 메서드를 사용**하는 것이 적절하다.

- **상한 와일드카드**
  - `<? extends Animal>`
  - `Animal` 과 그 하위 타입만 입력 받는다. 만약 다른 타입을 입력하면 컴파일 오류가 발생한다.
- 하한 와일드카드

  - `<? super Animal>`
  - `?` 가 `Animal` 타입을 포함한 `Animal` 타입의 상위 타입만 입력 받을 수 있다는 뜻이다.

- 와일드카드는 주로 이미 정의된 제네릭 타입의 객체를 메서드 인자 등으로 받을 때, 유연하게 타입을 표현하기 위해 사용된니다.  
  선언이 아니다!

<br/>

- **배열의 특징**

  - 배열에서 자료를 찾을 때 인덱스(index)를 사용하면 매우 빠르게 자료를 찾을 수 있다.
    - 인덱스를 통한 입력, 변경, 조회의 경우 한번의 계산으로 자료의 위치를 찾을 수 있다.
    - `arr[2]` 에 위치한 자료를 찾는다고 가정해보자.
    - 배열은 메모리상에 순서대로 붙어서 존재한다.
    - `int` 는 `4byte` 를 차지한다.
    - 따라서 배열의 **시작 위치**인 x100 부터 시작해서 자료의 크기(4byte)와 **인덱스 번호를 곱하면 원하는 메모리 위치를 찾을 수 있다.**
    - 배열의 시작 참조(x100) + (자료의 크기(4byte) \* 인덱스 위치(2)) = x108이 나온다. 여기에는 숫자 10이 들어있다.
  - **간단 정리**
    - 공식: `배열의 시작 참조 + (자료의 크기 * 인덱스 위치)`
    - `arr[0]: x100 + (4byte * 0): x100`
    - `arr[1]: x100 + (4byte * 1): x104`
    - `arr[2]: x100 + (4byte * 2): x108`

- **시간 복잡도와 실제 성능**

  - 이론적으로 `LinkedList`의 중간 삽입 연산은 `ArrayList`보다 빠를 수 있다.  
    그러나 실제 성능은 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에 의해 영향을 받는다.
  - 추가로 `ArrayList`는 데이터를 한 칸씩 직접 이동하지 않고, 대신에 메모리 고속 복사를 사용한다.
  - `ArrayList`는 요소들이 메모리 상에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.
  - 반면, `LinkedList`는 각 요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느려질 수 있다.
  - `ArrayList`의 경우 CAPACITY를 넘어서면 배열을 다시 만들고 복사하는 과정이 추가된다. 하지만 한번에 50%씩 늘어나기 때문에 이 과정은 가끔 발생하므로, 전체 성능에 큰 영향을 주지는 않는다.
  - **정리하면 이론적으로 LinkedList가 중간 삽입에 있어 더 효율적일 수 있지만, 현대 컴퓨터 시스템의 메모리 접근 패턴, CPU 캐시 최적화, 메모리 고속 복사 등을 고려할 때 ArrayList가 실제 사용 환경에서 더 나은 성능을 보여주는 경우가 많다.**

- **배열 리스트 vs 연결 리스트**

  - 대부분의 경우 배열 리스트가 성능상 유리하다. 이런 이유로 실무에서는 주로 배열 리스트를 기본으로 사용한다.
  - 만약 데이터를 앞쪽에서 자주 추가하거나 삭제할 일이 있다면 연결 리스트를 고려하자.

- **Set**

  - 중복을 허용하지 않고, 순서를 보장하지 않는 자료 구조이다.
  - 특징:
    - 유일성: **Set에는 중복된 요소가 존재하지 않는다.** 셋에 요소를 추가할 때, 이미 존재하는 요소면 무시된다.
    - 순서 미보장: 대부분의 셋 구현에서는 요소들의 **순서를 보장하지 않는다.** 즉, 요소를 출력할 때 입력 순서와 다를 수 있다.
    - **빠른 검색**: 셋은 요소의 유무를 빠르게 확인할 수 있도록 최적화되어 있다. 이는 데이터의 중복을 방지하고 빠른 조회를 가능하게 한다.
  - 구현체:
    - HashSet:
      - 가장 일반적으로 사용되는 Set 구현체이다.
      - 내부적으로 해시 테이블(Hash Table)을 사용하여 요소를 저장하므로 **검색, 추가, 삭제 속도가 매우 빠르다.**
      - 순서를 전혀 보장하지 않는다.
      - 검색, 추가, 삭제가 평균 O(1).
      - null 값을 하나만 저장할 수 있다.
      - 배열에 데이터 양이 75% 이상이면 배열의 크기를 2배로 증가하고, 모든 데이터의 해시 인덱스를 커진 배열에 맞춰 다시 계산한다. (재해싱(rehashing)이라 함)
    - LinkedHashSet:
      - HashSet을 상속받아 모든 특징이 같지만, 추가적으로 **입력 순서를 유지**한다.
      - 내부적으로 해시 테이블 + 링크드 리스트 구조 사용.
      - 순서가 중요한 경우 사용.
    - TreeSet:
      - 이진 탐색 트리(**Red-Black Tree**) 자료 구조를 기반으로 하여 요소들을 **자동으로 정렬**한다.
      - 검색, 추가, 삭제가 O(log n).
      - 요소들은 기본적으로 오름차순으로 정렬되며, 별도의 정렬 기준을 지정할 수도 있다.
      - 정렬된 상태로 데이터를 관리하고 검색해야 할 때 유용하다.
      - 다른 Set 구현체에 비해 추가 및 삭제 속도가 상대적으로 느리다.
  - 집합 연산 메서드:
    - 합집합: `addAll(Collection<? extends E> c)`
    - 교집합: `retainAll(Collection<?> c)`
    - 차집합: `removeAll(Collection<?> c)`
    - 포함 관계 확인: `containsAll(Collection<?> c)`
  - HashSet은 객체의 중복 여부를 판단할 때 hashCode() 값과 equals() 메서드 결과를 모두 사용한다. 사용자 정의 객체의 내용 기반 중복 체크를 위해 이 둘을 함께 구현해야 한다.

- **Map**

  - 주요 함수:
    - `keySet()`: `Map`에 사용했던 key 목록을 반환한다. `Map`의 키는 중복을 허용하지 않기 때문에, `Set` 자료형으로 반환된다.
    - `values()`: 값 목록으로 반환한다. 입력 순서를 보장하지 않기 때문에 `List`가 아닌 상위 인터페이스인 `Collection`으로 반환한다.
    - `containsKey()`: 파라미터 값으로 key 를 넣으면 해당 key 가 `Map`에 존재하는지 확인한다. true / false 반환.
    - `putIfAbsent("A", 100)`: A라는 key 가 없으면 해당 key : value 를 추가한다.
  - Set`과`Map` 의 구현체는 거의 같다.
    - `HashSet -> HashMap`
    - `LinkedHashSet -> LinkedHashMap`
    - `TreeSet -> TreeMap`
      > 실제로 자바 `HashSet` 의 구현은 대부분 `HashMap` 의 구현을 가져다 사용한다. `Map` 에서 `Value` 만 비워두면 `Set` 으로 사용할 수 있다.
  - 구현체:
    - HashMap:
      - **구조**: `HashMap` 은 해시를 사용해서 요소를 저장한다. 키(`Key` ) 값은 해시 함수를 통해 해시 코드로 변환되고, 이 해시 코드는 데이터를 저장하고 검색하는 데 사용된다.
      - **특징**: 삽입, 삭제, 검색 작업은 해시 자료 구조를 사용하므로 일반적으로 상수 시간(`O(1)` )의 복잡도를 가진다.
      - **순서**: 순서를 보장하지 않는다.
    - LinkedHashMap:
      - **구조**: `LinkedHashMap` 은 `HashMap` 과 유사하지만, 연결 리스트를 사용하여 삽입 순서 또는 최근 접근 순서에 따라 요소를 유지한다.
      - **특징**: 입력 순서에 따라 순회가 가능하다. `HashMap` 과 같지만 입력 순서를 링크로 유지해야 하므로 조금 더 무겁다.
      - **성능**: `HashMap` 과 유사하게 대부분의 작업은 `O(1)` 의 시간 복잡도를 가진다.
      - **순서**: 입력 순서를 보장한다.
    - TreeMap:
      - **구조**: `TreeMap` 은 레드-블랙 트리를 기반으로 한 구현이다.
      - **특징**: 모든 키는 자연 순서 또는 생성자에 제공된 `Comparator` 에 의해 정렬된다.
      - **성능**: `get` , `put` , `remove` 와 같은 주요 작업들은 `O(log n)` 의 시간 복잡도를 가진다.
      - **순서**: 키는 정렬된 순서로 저장된다.
  - Map에서 키 객체의 동등성을 정확히 판단하고 해시 충돌을 효율적으로 관리하기 위해 `equals()`와 `hashCode()` 메소드를 쌍으로 구현해야 한다.

- **Stack**

  - **후입 선출 (LIFO)**
  - `push()`: 값 넣기
  - `pop()`: 값 꺼내기
  - `peek()`: 다음 꺼낼 요소 확인(꺼내지 않고 단순 조회만)
    > Java에 `java.util.Stack` 이 존재하지만, 사용하지 말자.  
    > `Stack`은 `Vector` 라는 자료 구조를 사용하는데, 이 자료구조는 자바 1.0에 개발되었다. 지금은 사용되지 않고 하위 호환을 위해 존재한다.  
    > 지금은 더 빠른 좋은 자료 구조가 많다. 따라서 `Vector` 를 사용하는 `Stack` 도 사용하지 않는 것을 권장한다.

- **Queue**

  - **선입 선출 (FIFO)**
  - `offer`: 값 넣기
  - `poll`: 값 꺼내기
  - `peek()`: 다음 꺼낼 요소 확인(꺼내지 않고 단순 조회만)
  - `Queue` -> `Dqueue` -> `ArrayDeque` or `LinkedList`

- **Deque**
  - "Deque"는 "Double Ended Queue"의 약자로, 이 이름에서 알 수 있듯이, Deque는 양쪽 끝에서 요소를 추가하거나 제거할 수 있다. Deque는 일반적인 **큐(Queue)와 스택(Stack)의 기능을 모두 포함**하고 있어, 매우 유연한 자료 구조
    이다.
  - `offerFirst()` : 앞에 추가한다.
  - `offerLast()` : 뒤에 추가한다.
  - `pollFirst()` : 앞에서 꺼낸다. (stack 역할)
  - `pollLast()` : 뒤에서 꺼낸다. (queue 역할)
  - 대표적인 구현체는 `ArrayDeque` , `LinkedList` 가 있다. 이 둘 중에 `ArrayDeque` 가 모든 면에서 더 빠르다.
    - `ArrayDeque` 는 원형 큐 자료 구조를 사용
  - `Deque` 를 `Stack` 과 `Queue` 로 사용하기 위한 메서드도 제공한다.
    - `push()` 를 호출하면 앞에서 입력한다.
    - `pop()` 을 호출하면 앞에서 꺼낸다
    - `offer()` 를 호출하면 뒤에서 입력한다.
    - `poll()` 을 호출하면 앞에서 꺼낸다.
  - Stack`자료 구조가 필요하면`Deque`에`ArrayDeque` 구현체를 사용
  - 단순히 `Queue` 의 기능만 필요하면 `Queue` 인터페이스를 사용하고, 더 많은 기능이 필요하다면 `Deque` 인터페이스를 사용하면 된다. 그리고 구현체로 성능이 빠른 `ArrayDeque` 를 사용하자
