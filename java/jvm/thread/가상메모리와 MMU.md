# 가상 메모리와 MMU

## 1. 가상 메모리 (Virtual Memory)

### **핵심 정의**

각 프로세스에게 실제 물리 메모리(RAM)와는 독립된 가상의 주소 공간을 제공하는 메모리 관리 기법이다.

### **주요 역할 및 이점**

1.  **메모리 보호:** 프로세스마다 독립된 공간을 할당하여 서로의 메모리 영역을 침범할 수 없도록 격리한다. 하나의 오류가 시스템 전체로 확산되는 것을 막아 안정성을 확보한다.

2.  **메모리 확장:** '요구 페이징' 기법으로 당장 필요한 데이터만 RAM에 올리고 나머지는 하드디스크에 둔다. 이를 통해 실제 RAM보다 큰 프로그램 실행이 가능해지고, 메모리 사용 효율을 극대화한다.

3.  **개발 편의성:** 개발자가 물리 메모리의 복잡한 상태를 신경 쓸 필요 없이, 자신만의 크고 연속적인 공간을 가정하고 프로그래밍할 수 있도록 단순화된 환경을 제공한다.

---

## 2. MMU (Memory Management Unit)

- **핵심 정의:** 프로그램이 사용하는 **가상 주소**를 실제 RAM의 **물리 주소**로 실시간 번역해주는 **하드웨어**이다.
- **설명:** CPU와 메모리(RAM) 사이에 위치하는 실시간 주소 번역가이다. CPU가 가상 주소를 요청할 때마다, MMU는 '페이지 테이블'이라는 지도를 보고 해당 데이터가 저장된 실제 물리 주소를 찾아낸다.

> 가상 주소란, 프로그램이 실제 RAM의 위치는 신경 쓰지 않고, 자신만의 독립된 메모리 공간이 있는 것처럼 착각하고 사용하는 논리적인 주소이다.

---

## 3. 페이지 테이블 (Page Table)

- **핵심 정의:** 가상 주소가 물리 주소에 어떻게 매핑(mapping)되어 있는지를 기록해 둔 **'주소 변환 지도'** 이다.
- **설명:** 운영체제가 프로세스마다 하나씩 관리하는 데이터 구조이다. 이 테이블에는 '가상 메모리의 X번 페이지는 물리 메모리(RAM)의 Y번 프레임에 있다'는 식의 매핑 정보가 담겨 있다. MMU는 이 표를 보고 주소를 번역한다.

> **TLB (Translation Lookaside Buffer):**  
> 매번 페이지 테이블을 참조하는 것은 비효율적일 수 있다. 그래서 MMU는 내부에 **TLB**라는 이름의 **초고속 주소 변환 캐시(Cache)** 를 가지고 있다. 최근에 변환했던 가상-물리 주소 쌍을 여기에 잠시 저장해두었다가, 동일한 요청이 오면 페이지 테이블까지 가지 않고 즉시 처리하여 속도를 비약적으로 향상시킨다.

---

## 4. 페이지 폴트 (Page Fault)

- **핵심 정의:** MMU가 가상 주소를 물리 주소로 변환하는 과정에서, 참조한 페이지 테이블의 항목이 유효하지 않을 경우(즉, 해당 페이지가 RAM에 없을 경우) **CPU에 발생하는 하드웨어 예외(Hardware Exception) 또는 트랩(Trap)** 이다.
- **설명:** 이것은 '시스템 오류'가 아니다. MMU가 주소 변환을 위해 페이지 테이블을 확인했는데, 해당 페이지가 '현재 RAM에 없음'이라고 표시되어 있으면 페이지 폴트가 발생한다.  
  이 신호는 CPU가 하던 일을 잠시 멈추게 하고, 제어권을 **운영체제(커널)** 에게 넘긴다. 제어권을 넘겨받은 커널은 하드디스크에서 해당 데이터를 RAM으로 가져온 뒤 페이지 테이블을 수정하고, 멈췄던 작업을 다시 시작시켜 일이 끊김 없이 계속되도록 한다.

---

## 5. 가상메모리 동작 과정

1.  **가상 주소 요청:** `프로세스`는 자신만의 **가상 메모리** 공간 위에서 동작한다. 따라서 특정 데이터가 필요할 때, 이를 실행하는 `CPU`를 통해 **가상 주소**를 요청한다.

2.  **MMU의 TLB 확인:** **MMU**는 가장 먼저 내부의 초고속 캐시인 **TLB**를 확인하여 해당 가상 주소에 매핑된 물리 주소가 있는지 찾는다.

    - **(성공 시):** TLB에 정보가 있으면, 즉시 **물리 주소**로 변환한다. 이 물리 주소를 기반으로 **메모리 컨트롤러**가 RAM의 데이터를 **데이터 버스**를 통해 최종 목적지인 **CPU**의 레지스터로 전달한다. (가장 빠름)

3.  **MMU의 페이지 테이블 확인:** TLB에 정보가 없으면, MMU는 **페이지 테이블**을 조회한다.

    - **(성공 시):** 페이지 테이블에 유효한 **물리 주소** 정보가 있으면, 이를 통해 2번의 성공 시와 동일한 과정(메모리 컨트롤러 -> 데이터 버스 -> CPU)을 거쳐 데이터가 **CPU**로 전달된다.

4.  **페이지 폴트 발생:** 만약 페이지 테이블에도 해당 가상 주소에 대한 유효한 매핑 정보가 없다면(데이터가 RAM에 없다면), **페이지 폴트**가 발생한다.

5.  **운영체제의 개입:** 페이지 폴트 신호를 받은 **운영체제(커널)** 가 하드디스크에서 필요한 데이터를 RAM으로 가져온 뒤, **페이지 테이블**에 새로운 물리 주소를 기록한다.

6.  **작업 재개:** 운영체제의 조치가 끝나면, 중단되었던 명령이 다시 실행된다. 이제 MMU는 페이지 테이블에서 주소를 정상적으로 찾아 **물리 주소**로 변환하고, 마침내 데이터가 **CPU**에 전달된다.

> - **메모리 컨트롤러 (Memory Controller)**
>
>   - MMU가 번역해 준 최종 물리 주소를 받아서, 수많은 RAM 칩 중 정확히 어디에 데이터가 저장되어 있는지 찾아내고, 데이터를 꺼내도록 관리하고 지시하는 역할을 합니다.
>
> - **데이터 버스 (Data Bus)**
>   - 메모리 컨트롤러가 RAM에서 꺼내준 실제 데이터(0과 1의 전기 신호들)가 CPU까지 이동하는 물리적인 통로입니다.

### 가상메모리 및 MMU 동작 과정 서술

> 프로그램이 실행될 때 운영체제는 프로세스에게 독립된 메모리 영역을 부여하는데, 이것을 가상 메모리라고한다.  
> 이 가상 메모리 시스템을 사용하는 이유는 크게 두 가지이다.  
> 메모리 보호: 프로세스끼리 메모리가 충돌하거나 다른 프로세스의 데이터에 접근하는 것을 원천적으로 방지한다.  
> 메모리 확장: 실제 램(RAM) 용량보다 더 큰 프로그램을 실행할 수 있도록 해준다.  
> 프로세스는 이 가상 공간의 주소, 즉 가상 주소를 사용하여 데이터에 접근한다. 이 가상 주소를 실제 램의 물리 주소로 >바꾸는 역할을 하드웨어인 MMU가 담당한다.  
> MMU는 주소 변환을 위해 먼저 TLB(페이지 테이블의 고속 캐시)를 확인한다. 원하는 주소 변환 정보가 TLB에 없다면, >메모리에 있는 페이지 테이블을 참조하여 물리 주소를 찾아낸다. 물리 주소를 찾으면 메모리 컨트롤러가 해당 주소의 실제 >데이터를 읽어 CPU에 전달한다.  
> 만약 페이지 테이블을 확인했는데, 해당 페이지가 현재 물리 램에 없다고 표시되어 있다면(유효 비트(valid bit)가 0인 >경우), 이때 페이지 폴트가 발생한다. 그러면 CPU는 즉시 운영체제(커널)에게 제어권을 넘긴다. 커널은 하드디스크 (스왑 >영역)에서 필요한 데이터 페이지를 찾아 비어있는 램 공간에 적재한 후, 페이지 테이블에 새로운 맵핑 정보를 기록한다. 그 >후 중단됐던 명령을 다시 실행하면 정상적으로 메모리 접근이 이루어진다.  
> 추가로, 가상 메모리를 사용하면 램보다 더 큰 용량을 사용할 수 있게 되냐면, 프로그램의 모든 부분을 항상 램에 올려두지 >않고, 지금 당장 실행에 필요한 부분만 램에 올려놓고 나머지는 하드디스크에 저장해두기 때문이다.
