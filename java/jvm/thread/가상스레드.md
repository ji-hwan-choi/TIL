# Java 가상 스레드 (Virtual Thread)

## 기존 플랫폼 스레드 방식

- Java의 기본 Thread는 **OS 스레드와 1:1로 매핑된다**.
- **스레드 풀**에서 스레드 개수를 제한하여 관리하며 (예: 100개), 각 스레드는 **스택 메모리(보통 1MB 이상)**를 차지하고 컨텍스트 스위칭 비용 또한 크다.
- IO 작업이나 `sleep()` 중에도 **스레드를 계속 점유**하기 때문에, 풀에 여유가 없으면 새로운 요청을 처리할 수 없다.

---

## 가상 스레드 (Java 21부터)

- **OS 스레드와 1:1로 매핑되지 않으며**, JVM이 직접 관리하는 **논리적 스레드이다**.
- 실행 시 **캐리어 스레드(구 플랫폼 스레드)** 위에 "마운트"되어 동작한다.
- IO 대기나 `sleep()` 같은 블로킹 상황이 발생하면 **즉시 언마운트**되고, 해당 캐리어 스레드는 다른 가상 스레드를 실행하는 데 재사용된다.
- **수만 개까지도 생성 가능**할 정도로 매우 가볍고 비용이 적다.

---

## 동작 구조

```
많은 가상 스레드
   ⇅ (마운트 / 언마운트)
소수의 캐리어 스레드 (플랫폼 스레드)
   ⇅
OS 스레드 & CPU 코어
```

---

## 장점

- **높은 처리량**: 수많은 동시 요청 처리가 가능하다. (특히 IO-bound 작업에 강력하다)
- **자원 효율성**: 스레드 풀 개수를 제한할 필요가 없으며, 메모리 사용량을 대폭 감소시킨다.
- **코드 단순성**: 동기식 코드 스타일을 유지하면서 비동기 처리 효과를 실현한다.

## 단점

- **CPU-Bound 작업에는 부적합**: 가상 스레드는 I/O 대기 시간을 최적화하는 데 초점이 맞춰져 있다. 복잡한 연산처럼 CPU를 계속 사용하는 작업에는 이점이 없으며, 이 경우 기존 플랫폼 스레드를 통한 병렬 처리가 더 유리하다.
- **디버깅 및 모니터링의 복잡성**: 수많은 가상 스레드가 소수의 캐리어 스레드를 오가므로 스택 트레이스 추적이 복잡할 수 있으며, 기존 모니터링 툴에서 동작을 파악하기 어려울 수 있다.
- **힙 메모리 소진 가능성**: 스택 메모리는 거의 차지하지 않지만, 가상 스레드 객체 자체는 힙 메모리를 사용한다. 수백만 개를 무분별하게 생성하면 힙 메모리 부족으로 OutOfMemoryError가 발생할 수 있다.

---

## 예시 시나리오

- **스레드 풀 100개 + 3000개 요청 + 1초 sleep**
  - **기존 방식**: 100개씩 순차 처리하므로 → 총 30초가 소요된다.
  - **가상 스레드**: 3000개 요청이 동시에 sleep에 진입하므로 → 총 1초가 소요된다.

---

## 주의사항

- 가상 스레드도 결국 **캐리어 스레드(플랫폼 스레드)** 위에서 실행되므로, OS 스레드가 무제한으로 늘어나는 것은 아니다.
- JVM이 캐리어 스레드 수를 자동으로 관리하지만, **커스텀 Executor를 사용할 때는 개수를 직접 잘 설계해야 한다**.
- **`synchronized` 블록 사용 주의**: 가상 스레드가 `synchronized` 블록에 진입하면, 해당 캐리어 스레드가 **고정(pinning)**된다. 이 스레드는 블록이 끝날 때까지 다른 가상 스레드에 할당될 수 없는 **'블로킹' 상태**가 되어 가상 스레드의 핵심 장점이 사라진다. 따라서 `java.util.concurrent.locks.ReentrantLock` 사용이 권장된다.

---

## 핵심 한 줄 요약

> **가상 스레드는 IO 대기 중 스레드를 반납하여 수많은 요청을 동시에 처리할 수 있게 하며, 더는 스레드 풀 개수 제한에 얽매이지 않는다. (단, `synchronized`는 피하는 것이 좋다.)**
