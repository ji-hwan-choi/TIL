# 스레드 내용 정리

## 프로그램, 프로세스, 스레드

- **프로그램 (Program):** 특정 작업을 수행하기 위해 작성된 코드와 데이터의 묶음으로, 디스크와 같은 저장 장치에 존재하는 정적인 상태의 실행 파일이다.
- **프로세스 (Process):** 실행 중인 프로그램을 의미하는 동적인 상태이다. 운영체제로부터 독립적인 메모리 공간(Code, Data, Heap, Stack)을 할당받으며, 자원 할당의 기본 단위가 된다. 모든 프로세스는 최소 하나 이상의 스레드를 가진다.
- **스레드 (Thread):** 프로세스 내에서 실제 작업이 실행되는 흐름의 단위이다. 프로세스의 자원을 공유하면서 실행되며, CPU 스케줄링의 기본 단위가 된다. '경량 프로세스(Light-weight Process)'라고도 불린다.

## 스레드의 공유 자원, 독립 자원

- **공유 자원 (Shared Resources):** 같은 프로세스에 속한 모든 스레드가 공유하는 메모리 영역이다.

  - **코드 영역 (Code Segment):** 실행할 프로그램의 기계어 코드가 저장되는 공간이다. 모든 스레드는 이 코드를 함께 사용한다.
  - **데이터 영역 (Data Segment):** **전역 변수(Global variables)와 정적 변수(Static variables)** 가 저장되는 공간이다. 프로세스가 시작될 때 할당되어 끝날 때까지 유지된다.
  - **힙 영역 (Heap):** 프로그래머가 **동적으로 할당** 하는 메모리 공간입니다. 모든 스레드가 이 공간을 공유한다.

- **독립 자원 (Independent Resources):** 각 스레드가 독립적으로 할당받는 메모리 영역으로, 다른 스레드와 공유하지 않는다.
  - **스택 (Stack):** 메서드 호출 시 사용되는 지역 변수, 매개변수, 리턴 값 등이 저장되는 공간이다. 스레드마다 별도의 스택을 가진다.
  - **프로그램 카운터 (Program Counter, PC): 스레드가 다음에 실행할 명령어의 주소를 가리키는 레지스터이다.**
  - **레지스터 집합 (Register Set):** CPU 연산에 사용되는 레지스터들의 값이다.

> #### 스레드 컨텍스트 스위칭이 프로세스 컨텍스트 스위칭보다 빠른 이유
>
> **작업 전환 시 교체해야 할 데이터의 범위가 훨씬 작기 때문이다.**
>
> 프로세스 간의 작업 전환은 완전히 독립된 메모리 공간을 전환하는 과정이다.
>
> 1. 페이지 현재 프로세스의 페이지 테이블울 내리고, 새로운 프로세스의 페이지 테이블로 완전히 교체한다.
> 2. 주소 공간이 바뀌었기 때문에, 기존의 주소 변환 캐시(TLB)는 더 이상 유효하지 않으므로 모든 내용을 비워야 한다. 이는 큰 성능 저하를 유발한다.
> 3. 현재 프로세스의 모든 상태(레지스터, 메모리 정보, 파일 목록 등)를 해당 프로세스의 **PCB(Process Control Block)** 에 저장하고, 새로 실행할 프로세스의 PCB 정보를 불러온다.
>
> 반면, 같은 프로세스 내의 스레드 간 작업 전환은 **Code, Data, Heap 영역 등의 메모리 공간을 그대로 공유한다.** 따라서 운영체제는 스레드의 독립 자원인 **스택 포인터, 프로그램 카운터(PC), 레지스터 상태** 등 최소한의 정보만 저장하고 복원하면 된다. 무거운 메모리 전체를 전환하는 과정이 없으므로 훨씬 적은 비용으로 빠르게 작업을 전환할 수 있는 것이다. **(TCB만 교체)**

---

## 사용자 모드와 커널 모드의 전환 원리

### 사용자 모드와 커널 모드

- 우리가 개발한 코드는 일반적으로 **User mode(사용자 모드)** 에서 실행된다.
- 실행 중 인터럽트가 발생하거나 시스템 콜(system call)을 호출하면 **Kernel mode(커널 모드)** 로 전환된다.

### 커널 모드 동작 흐름

1. **모드 전환**  
   시스템 콜이나 인터럽트가 발생하면 **현재 CPU 상태를 저장** 하고 커널 모드로 전환된다.

2. **인터럽트 또는 시스템 콜 처리**  
   커널이 직접 개입하여 해당 요청을 처리한다. 이때 CPU는 커널 코드만 실행할 수 있다.

3. **복귀**  
   작업이 끝나면 저장했던 CPU 상태를 복원하고 다시 **User mode** 로 돌아가 프로그램 실행을 이어간다.

> **커널 모드(Kernel Mode)**  
>  **커널(Kernel)** 이 컴퓨터의 모든 자원을 제어하고 관리하기 위해 사용하는, CPU의 가장 높은 권한을 가진 실행 모드이다.  
> 이 모드에서 커널은 메모리 할당, 프로세스 생성, 디스크 입출력과 같이 하드웨어에 직접 접근해야 하는 중요 작업을 수행한다.  
> 또한, 시스템 전체를 관리하는 데 필요한 **'특권 명령어(Privileged Instructions)'** 를 실행할 수 있는 유일한 모드이다.  
> 이러한 권한 분리는 일반 응용 프로그램이 **시스템의 핵심 자원을 직접 건드려 발생시킬 수 있는 오류나 보안 문제를 원천적으로 차단**하여, **시스템 전체의 안정성을 보장**하는 핵심적인 역할을 한다.

### 커널(Kernel)

- 운영체제의 핵심으로 시스템의 전반을 관리/감독하며 하드웨어와 관련된 작업 수행.

### 인터럽트 (Interrupt)

프로그램의 의지와 상관없이 외부 요인(하드웨어)이나 예외 상황에 의해 발생하는 이벤트이다. 프로그램 입장에서는 예상치 못하게 '당하는' 것에 가깝다.

- **종류**: 전원 문제, I/O 완료, 타이머 만료, 0으로 나누기, 메모리 접근 오류 등.
- **처리 과정**: 인터럽트가 발생하면 CPU는 즉각적으로 커널 모드에서 인터럽트 처리 코드를 실행한다.

### 시스템 콜 (System Call)

프로그램이 자신의 코드 흐름에 따라 스스로, 의도적으로 커널의 기능을 사용하기 위해 요청하는 행위이다.  
프로그램이 주체가 되어 일으키는 것이다.

- **종류**: 파일 열기/닫기, 프로세스 생성, 스레드 생성, 소켓 통신, 장치 제어 등.
- **보안 목적**: 모든 시스템 자원은 반드시 시스템 콜을 통해서만 접근할 수 있다.

> - 일반 Java 프로그램은 시스템 콜을 직접 호출하지 않는다.
> - 대신 **JNI (Java Native Interface)** 가 중간에서 시스템 콜을 대신 호출해 OS와 연결해준다.

---

## 자바 스레드는 어떻게 운영체제 스레드와 연결되는가?

**유저 스레드**: 스레드 개념을 프로그래밍 레벨에서 추상화한 것이다.

자바로 예를 들면, `new Thread()`로 유저 스레드를 만들고 `.start()`를 호출하면, JNI를 통해 시스템 콜이 호출되어 OS 레벨 스레드가 생성되고 유저 스레드와 연결된다. 유저 스레드가 CPU에서 실행되려면 OS 스레드와 반드시 연결돼야 한다.

현대 자바는 **One-to-One 모델**을 사용하여 유저 스레드와 OS 스레드를 1:1로 매핑한다.  
One-to-One 모델은 스레드 관리(스케줄링 포함)를 운영체제에 위임

**[1:1 모델의 장점]**

- 스레드 관리를 OS에게 위임하며, 스케줄링을 커널이 직접 수행한다.
- 각 스레드가 다른 코어에 배분될 수 있어 멀티코어를 효율적으로 활용한다.
- 하나의 스레드가 I/O 작업으로 인해 대기(Block) 상태가 되어도 다른 스레드는 영향을 받지 않고 실행된다.

**[1:1 모델의 특징]**

- 진정한 의미의 병렬 실행이 가능해지므로, 여러 스레드가 공유 자원에 동시에 접근할 때 발생하는 **경쟁 상태(Race Condition)를 개발자가 동기화(Synchronization)를 통해 직접 관리**해야 할 책임이 있다.

---

## OS 스레드의 생명 주기: 모든 개념의 총정리

운영체제가 관리하는 스레드의 상태는 크게 **`NEW`**, **`READY`**, **`RUNNING`**, **`WAITING`**, **`TERMINATED`** 로 나뉜다.

#### `NEW` (생성)

프로그래머가 `Thread.start()`와 같은 코드를 실행하면, **시스템 콜**이 호출되어 커널에 스레드 생성을 요청한다. 커널은 이 요청을 받아 스레드를 식별하고 관리하는 데 필요한 정보 집합인 **TCB(Thread Control Block)** 를 커널 메모리 공간에 생성한다. 이 TCB에는 스레드 ID, 앞으로 실행할 명령어의 주소(PC), 레지스터 초기값 등이 저장된다. 이렇게 TCB만 생성되고 아직 스케줄링 대상은 아닌 상태가 `NEW`이다.

#### `READY` (준비)

`NEW` 상태에서 스레드에 필요한 모든 자원 할당이 끝나면, 스레드는 CPU를 받아 실행될 준비가 되었다는 의미로 `READY` 상태가 된다. 이 상태의 스레드들은 **Ready Queue**라는 대기열에 들어가 **커널 스케줄러**의 선택을 기다린다.

#### `RUNNING` (실행)

**커널 스케줄러**가 스케줄링 알고리즘에 따라 Ready Queue에 있는 스레드 중 하나를 선택하면, **디스패처**가 해당 스레드에게 CPU 제어권을 넘겨준다. 이 상태가 CPU를 점유하고 코드를 실행하는 `RUNNING` 상태이다.

이때, 한 스레드에서 다른 스레드로 CPU 제어권이 넘어가는 것을 **컨텍스트 스위칭(Context Switching)** 이라 한다. 디스패처는 기존 스레드의 실행 정보(PC, 레지스터 등)를 TCB에 저장하고, 새로 실행될 스레드의 정보를 TCB에서 가져와 CPU에 로드하는 역할을 한다.

#### `RUNNING` → `READY` (전환: 타임 슬라이스 만료)

하나의 스레드가 CPU를 독점하는 것을 막기 위해, 운영체제는 **타이머 인터럽트**를 사용한다. 스레드에 할당된 시간(**타임 슬라이스**)이 다 되면 타이머 인터럽트가 **발생**하고, 해당 스레드는 다시 `READY` 상태로 돌아가 Ready Queue의 맨 뒤에서 차례를 기다린다.

#### `RUNNING` → `WAITING` (전환: 블로킹 시스템 콜)

`RUNNING` 상태의 스레드가 파일 I/O 작업이나 `sleep()`처럼 시간이 오래 걸리는 작업을 **시스템 콜**로 요청하면, 커널은 해당 스레드를 즉시 `WAITING` 상태로 전환한다. 이는 CPU를 낭비하지 않고 다른 스레드에게 실행 기회를 주기 위함이다.

#### `WAITING` → `READY` (전환: 인터럽트 발생)

`WAITING` 상태의 원인이 해결되면 스레드는 다시 `READY` 상태로 돌아간다. 예를 들어, 요청했던 I/O 작업이 완료되면 디스크 컨트롤러가 CPU에 **하드웨어 인터럽트**를 발생시켜 작업 완료를 알린다. 이 신호를 받은 커널은 해당 스레드를 `WAITING` 상태에서 깨워 Ready Queue에 넣어준다.

#### `TERMINATED` (종료)

스레드가 맡은 모든 작업을 마치고 실행이 정상적으로 종료되면 `TERMINATED` 상태가 된다. 이 상태가 되면 커널은 해당 스레드의 TCB와 관련된 모든 시스템 자원을 해제하며, 스레드의 생명 주기는 완전히 마감된다.
