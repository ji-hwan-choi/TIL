# G1GC 심화 내용

## Card Table과 RSet의 역할 정리

#### 개념 요약

- **Card Table**은 Old 영역의 객체가 **다른 객체를 참조할 때 변경이 일어난 위치를 추적하기 위한 테이블**이다.
  - Old 영역을 전체 탐색하지 않아도 되게 만든 메커니즘이다.
- **RSet(Remembered Set)** 은 각 Region이 **자기 자신을 참조하고 있는 외부 Region의 카드 정보(Card Index)를 저장하는 집합**이다.
- 이 두 구조 덕분에 GC는 **전체 Heap을 스캔하지 않고도** 필요한 참조 관계를 빠르게 탐색할 수 있다.
  - RSet은 Card Table 전체를 다 뒤지지 않기 위해 '요약본'을 유지하는 구조이다.

---

### Card란 무엇인가?

- Heap은 Region으로 나뉘고, **각 Region은 다시 Card라는 고정 크기(보통 512 byte)** 단위로 나뉜다.
- 이 카드 하나하나에 대해 객체 참조 변경이 일어났는지 여부를 `Card Table`이라는 별도 메모리 구조에 **"Dirty" 비트**로 기록한다.

### Card Table이란 무엇인가?

| 항목          | 설명                                                                                              |
| ------------- | ------------------------------------------------------------------------------------------------- |
| **정의**      | JVM이 Heap을 **작은 카드 단위(보통 512byte)** 로 나눈 후, 각 카드의 상태를 저장한 **바이트 배열** |
| **기능**      | 객체 참조가 변경되면, 해당 객체가 위치한 카드의 인덱스에 **Dirty 표시(0x01 등)**                  |
| **주 목적**   | **Old 객체가 어떤 Young 객체를 참조하는지**를 빠르게 추적                                         |
| **동작 시점** | 참조 필드 변경 시 JVM의 Write Barrier가 카드에 Dirty 표시                                         |

### Card Table이 필요한 이유

Young GC에서는 Eden Region, Survivor Region만 수집하려고 한다.  
그런데 **Old 영역이 Young 객체를 참조하고 있다면**,  
GC는 **그 참조 대상도 확인**해야 한다.

그러나:

- Old 영역은 수 GB 이상일 수 있고,
- 전체를 다 스캔하면 시간이 너무 오래 걸린다.

이 문제를 해결하기 위해 **Card Table + RSet** 구조가 도입된다.

> **Old 영역에서 Young 객체로의 참조**는 Card Table을 통해 Dirty로 표시하고,  
> GC 시점에 해당 Card를 탐색해 참조된 Young 객체를 정확히 살펴본다.

---

### RSet은 어떤 역할을 하나?

- 특정 Region이 **외부에서 참조받는 카드 정보(카드 인덱스)** 를 모아둔 **역방향 참조 인덱스**이다.
- 이를 통해 **GC는 “나를 참조하고 있는 외부 객체들”을 빠르게 찾을 수 있다.**
- 즉, RSet은 **Card Table을 전체 훑는 수고조차 줄여주는 인덱스** 역할을 한다.

---

### 정리

| 항목           | 설명                                                                                  |
| -------------- | ------------------------------------------------------------------------------------- |
| **Card Table** | 어떤 객체(보통 Old 영역)가 **다른 객체를 참조할 때** 해당 카드에 Dirty 비트를 남긴다. |
| **RSet**       | 나(이 Region)를 참조하는 외부 카드 정보를 따로 모아둔 **역방향 인덱스**다.            |
| **동작 순서**  | 참조 변경 발생 → Card Table에 Dirty → RSet에 카드 번호 추가                           |

---

### Young → Young 참조일 경우?

- Young 영역 내 객체가 다른 Young 객체를 참조하는 경우, 해당 참조 변경은 **Card Table에 Dirty 표시되지 않는다.**
- 어차피 Eden, Survivor 모두 **CSet에 포함되므로**, 서로 간의 참조는 그대로 GC 탐색 범위에 포함된다.
- 따라서 **추적하지 않아도 안전**하다.

---

### 결론 요약

- **객체가 다른 객체를 참조할 때**, GC가 효율적으로 살아 있는 객체를 찾기 위해 Card Table을 활용한다.
- **Card Table은 Old 객체가 Young 객체를 참조하는 경우**에만 Dirty 처리를 한다.
- Dirty 카드만 검사하면 되므로, **전체 Old 영역을 풀스캔하지 않아도 된다.**
- 이 Dirty 카드 정보를 Region별로 모아둔 것이 **RSet**이다.
- **RSet이 없다면** GC는 모든 Region의 모든 Card Table을 뒤져야 한다.

---

### CSet(Collection Set)이란 무엇인가?

- CSet은 **GC가 실제로 수집할 Region들의 집합**이다.
- Young GC에서는:
  - **모든 Eden**
  - **일부 Survivor** 가 포함된다.
- Mixed GC에서는 여기에 **일부 Old Region도 추가된다.**

#### Old Region이 CSet에 포함되는 기준

- **Concurrent Marking과 Cleanup 단계**에서 수집된 메타데이터 기반
- 대표적인 선정 기준:
  - **Live Ratio가 낮은 Region 우선**
    > → 죽은 객체가 많아 수집 효율이 높기 때문
  - **최근 수집된 적 없는 Region 우선**
    > → 장기간 방치된 가비지 회수 유도
