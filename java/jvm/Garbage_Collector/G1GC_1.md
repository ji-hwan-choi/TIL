# G1GC(Garbage First Garbage Collector)

## 1. G1GC의 탄생 배경

기존 GC, 특히 **CMS(Concurrent Mark-Sweep)** 는 대규모 애플리케이션 환경에서 여러 **구조적 한계**를 드러냈다.  
**G1GC**는 이를 해결하고, **예측 가능한 짧은 GC 정지 시간(Pause Time)** 을 달성하기 위해 개발되었다.

### CMS의 주요 한계점

| 문제점                         | 설명                                                                                                                                 |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------ |
| **Heap 조각화(Fragmentation)** | CMS는 객체 제거 후 **압축(compaction)** 을 하지 않아, 시간이 지날수록 Heap이 조각나고 메모리 **할당 실패** 위험이 높아진다.          |
| **STW(Pause Time) 예측 불가**  | CMS는 병행 마크 이후 **Remark 단계**에서 긴 **Stop-The-World**가 발생할 수 있어 **실시간 응답성**이 요구되는 시스템에 적합하지 않다. |
| **세대별 분리 관리**           | **Young 영역**과 **Old 영역**을 별도로 관리하기 때문에 전체적인 GC **효율**이 떨어진다.                                              |
| **멀티코어 활용 낮음**         | CMS는 **멀티 코어 자원을 충분히 활용하지 못해** 최신 서버 환경에서 **비효율적**이다.                                                 |

### G1GC의 목표와 핵심 설계 아이디어

- **STW를 짧고 예측 가능하게 만드는 것이다.**
- 현대 애플리케이션은 수 GB 이상의 Heap을 사용하는 경우가 많기 때문에 기존 GC 구조로는 **안정적인 관리**가 어렵다.

G1GC의 **핵심 설계 전략**은 다음과 같다.

| 전략                        | 설명                                                                                           |
| --------------------------- | ---------------------------------------------------------------------------------------------- |
| **Region 기반 Heap 분할**   | 전체 Heap을 고정된 크기의 **Region** 단위로 나누어 **유연하고 효율적인 관리**가 가능하다.      |
| **Garbage-First 수집 순서** | **Garbage 비율이 높은 Region부터 우선 수집**함으로써 효율적인 회수가 가능하다.                 |
| **SATB 기반 병행 마킹**     | 객체 참조 변경을 추적하고 **정확한 마킹**이 가능하게 하여 **Remark 단계**를 짧게 만든다.       |
| **Full GC 방지 목적**       | **Young과 Old 세대**를 통합적으로 관리하고 **압축**을 지원하여 **Full GC 발생 빈도**를 낮춘다. |

---

## G1GC의 예측가능한 STW가 좋은점

G1GC가 10ms씩 열 번 멈추는 것이 (CMS GC 처럼)100ms 한 번보다 효율적인 이유는, STW의 틈틈이 새로운 I/O 작업을 시작하고, 완료된 I/O의 결과를 지연 없이 처리할 기회가 더 많기 때문이다.

첫째로, 이미 완료된 작업의 처리 지연이 줄어든다. 예를 들어 10ms가 걸리는 DB 조회가 끝났더라도, 100ms짜리 긴 STW가 진행 중이라면 스레드는 나머지 90ms를 아무것도 못 하고 낭비해야 한다.

둘째로, 새로운 작업을 시작할 틈이 생긴다. 긴 STW는 그 시간 동안 새로운 I/O 요청을 보내는 것조차 막아버리는 '업무 공백'을 만든다. 반면 짧은 STW는 멈춤 사이사이에 새로운 I/O 요청을 미리 보내둘 수 있어 시스템의 병렬성을 높인다.

현대 웹 애플리케이션은 대부분의 시간을 I/O 대기에 사용하므로, 긴 STW는 이 두 가지 측면 모두에서 **'시스템 전체의 병목'** 을 유발하여 서버의 처리량을 크게 떨어뜨린다.

결론적으로 G1GC의 짧은 STW는 새로운 작업을 시작할 틈을 확보하고, 완료된 작업의 처리 지연을 최소화하여 시스템 전체의 응답 시간을 단축시키고 처리량을 극대화하는 핵심 원리이다.

> - 완료된 I/O의 결과를 빠르게 처리해 지연을 줄인다.
> - STW 사이의 짧은 실행 시간을 활용해 새로운 I/O 작업을 미리 시작시켜 시스템의 유휴 시간을 줄인다.

---

## 2. G1GC 의 Heap 구조: Region

기존의 Young / Old 영역처럼 물리적으로 연속된 큰 덩어리를 사용하는 대신, G1은 **힙 전체를 바둑판처럼 여러 개의 동일한 크기의 'Region'으로 나눈다.**

### Region 기반 힙 구성

- G1GC는 전체 힙을 **균일한 크기의 Region 단위**로 나누어 관리한다.
- Region 크기는 1MB ~ 32MB 사이의 2의 제곱수여야 한다. (즉, 1, 2, 4, 8, 16, 32MB 중 하나)
- JVM 시작 시, 설정된 전체 힙 크기(`-Xmx`)를 기준으로 Region 개수가 약 2048개가 되도록 Region 크기를 자동 계산한다.
  > | 전체 힙 크기 (`-Xmx`) | 계산된 Region 크기 | 최종 Region 개수 | 비고                                            |
  > | --------------------- | ------------------ | ---------------- | ----------------------------------------------- |
  > | 512MB                 | 1MB                | 512개            | 최소 Region 크기(1MB) 제약으로 2048개보다 적음  |
  > | 8GB (8192MB)          | 4MB                | 2048개           | 목표치에 근접                                   |
  > | 32GB (32768MB)        | 16MB               | 2048개           | 목표치에 근접                                   |
  > | 128GB (131072MB)      | 32MB               | 4096개           | 최대 Region 크기(32MB) 제약으로 2048개보다 많음 |
- Region의 크기는 `-XX:G1HeapRegionSize` 옵션으로 수동 조정 가능하다.

### Region: 논리적으로 역할이 부여되는 단위

| 역할          | 설명                                                                                                                |
| ------------- | ------------------------------------------------------------------------------------------------------------------- |
| **Eden**      | 새로 생성된 객체들이 일시적으로 머무르는 영역                                                                       |
| **Survivor**  | Young GC에서 살아남은 객체들이 이동하는 임시 보존 영역                                                              |
| **Old**       | 일정 횟수 이상 생존한 객체들이 승격되어 저장되는 영역                                                               |
| **Humongous** | Region 크기의 50%를 초과하는 **거대 객체**가 직접 저장되는 영역. 여러 Region을 연속으로 차지하며, 모두 Old로 간주됨 |

- Region은 GC 주기마다 **필요에 따라 Eden, Survivor, Old 역할을 동적으로 부여받는다.**
- 예전처럼 Young 영역의 크기가 물리적으로 고정되어 있는 것이 아니라, GC 상황과 객체 분포에 따라 **동적으로 재구성된다.**

### Humongous Region의 특성

- Humongous 객체는 일반적으로 **배열이나 대용량 버퍼**와 같은 큰 객체들이다.
- 이 객체들은 한 Region에 담을 수 없기 때문에, **연속된 여러 Region에 걸쳐 저장된다.**
- 모든 Humongous Region은 **Old 영역으로 간주**되며, 회수가 까다롭고 과도하게 쌓이면 **Full GC를 유발할 수 있다.**

### Region 구조의 핵심 효과

- G1GC는 Heap을 Region 단위로 쪼갬으로써,  
  **전체 Heap이 아닌 일부 Region만 선택적으로 수집하는 방식**을 가능하게 만든다.
- 각 Region은 **Live 객체 비율(Live Ratio)** 과 관련된 메타데이터를 유지하며,

  > Live Ratio는 해당 Region에 얼마나 많은 객체가 살아남았는지를 의미함  
  >  이 값이 낮을수록, 해당 Region은 **"Garbage가 많다"** 고 간주되어 GC 우선 수집 대상이 된다.  
  >  이는 G1GC의 이름인 Garbage First 전략의 핵심 기준 지표 중 하나다.

  이 정보를 바탕으로 **Garbage 비율이 높은 Region부터 우선 수집**하는 전략을 수행한다.

- 또한 사용자 설정에 따라 GC가 소요할 수 있는 **최대 정지 시간(`-XX:MaxGCPauseMillis`)** 을 만족하도록 수집 대상 Region 수를 자동 조절할 수 있다.

---

## 3. G1GC의 실시간 자동 조정: 피드백 루프

G1GC는 GC가 끝난 이후, 그 실행 결과를 기반으로 다음 GC 전략을 실시간으로 조정한다.  
이러한 **자동 조정 기능** 덕분에 G1GC는 변화하는 메모리 상황에 맞게 **정지 시간과 처리 효율 사이의 균형을 유지**할 수 있다.

### Young Generation의 크기는 고정되어 있지 않다

- G1GC에서 Young Generation의 크기는 **전체 힙의 약 5% ~ 60% 범위 내에서 동적으로 조절된다.**
- 최초 JVM 실행 시, **5% 크기부터 시작**한다.  
  이는 G1GC가 **보수적이고 안전한 크기로 시작해 점진적으로 최적화하려는 성향** 때문이다.
- 이후에는 **매번 Young GC가 끝날 때마다, 직전 GC의 결과를 바탕으로 크기를 조정**한다.

### G1GC의 피드백 루프 구조

G1GC는 매번 Young GC 이후 다음과 같은 순서를 반복하며 스스로 튜닝을 진행한다.

| 단계                         | 설명                                                                              |
| ---------------------------- | --------------------------------------------------------------------------------- |
| **1. 실행 (Execute)**        | 미리 계획된 수의 Eden Region으로 Young GC를 수행한다.                             |
| **2. 측정 (Measure)**        | 이번 GC에서 실제로 발생한 **STW 시간(정지 시간)** 을 측정한다.                    |
| **3. 분석 (Analyze)**        | 측정된 STW 시간을, 사용자가 설정한 `-XX:MaxGCPauseMillis` 값과 비교하여 분석한다. |
| **4. 다음 계획 수립 (Plan)** | 분석 결과를 바탕으로, 다음 GC에서 사용할 Eden Region 수를 조절한다.               |

### 분석 결과에 따른 전략 조정

- **STW 시간이 목표보다 훨씬 짧았다면**  
  → 다음 GC에서 **Eden Region 수를 늘려** 한 번에 더 많은 객체를 처리함으로써 GC 빈도를 줄이고 처리량(Throughput)을 높인다.

- **STW 시간이 목표에 근접하거나 초과했다면**  
  → 다음 GC에서 **Eden Region 수를 줄여** 정지 시간을 단축하는 방향으로 전략을 전환한다.

### 이 피드백 루프의 효과

| 항목                                 | 설명                                                                                      |
| ------------------------------------ | ----------------------------------------------------------------------------------------- |
| **정지 시간 목표 유지**              | 사용자가 설정한 `-XX:MaxGCPauseMillis`를 기준으로 GC 정지 시간을 일정하게 유지한다.       |
| **처리량 최적화**                    | 불필요한 GC를 줄이고, 한 번의 GC로 더 많은 객체를 수집하는 방향으로 자동 조정이 가능하다. |
| **동적 메모리 환경에 유연하게 대응** | 애플리케이션의 부하 변화나 객체 생명 주기에 따라 GC 전략을 실시간으로 조절한다.           |

---

## 4. G1GC의 주요 GC 사이클: Young → Concurrent → Mixed → Full

G1GC는 다음 네 가지 단계를 중심으로 동작한다.  
각 단계는 명확한 트리거와 역할을 가지고 있으며, 특히 **Concurrent Marking과 Mixed GC**는 G1GC만의 핵심 전략이다.

### 1단계: Young GC (STW 발생)

- **언제 발생하나?**  
  Eden Region에 더 이상 객체를 할당할 공간이 없을 때 발생한다.

- **무엇을 수집하나?**  
  모든 Eden Region과 Survivor Region을 대상으로 살아 있는 객체를 찾아, 찾는 즉시 비어 있는 Region으로 **복사(Copying)** 한다.  
  이전 Region은 완전히 비운다.

- **객체 추적(Object Tracing) 종료 기준**

  1. 객체가 참조 그래프의 끝에 도달했을 때
  2. 탐색 중인 객체가 참조하는 다음 객체가 수집 대상(CSet)이 아닌 리전, 대표적으로 Old Region에 있을 경우, 해당 객체는 추적하지 않고 그 경로의 탐색을 종료
  3. 순환 참조로 인해 시작점으로 되돌아왔을 때
  4. 이미 복사가 된 객체를 만났을 때

- **객체 생존 흐름**  
  객체는 처음 Eden에 생성되며, Young GC에서 살아남으면 Survivor로 이동하고,  
  여러 번의 GC를 견디면 Old 영역으로 **승격(Promotion)** 된다.  
  이 기준은 `-XX:MaxTenuringThreshold`로 조정할 수 있다.

- **특징**  
  생존 객체를 표시(Marking)하는 단계 없이, 참조 그래프를 탐색하며 살아있는 객체를 발견하는 즉시 새로운 Region으로 복사(이동) 한다.

  > 아래 내용은 G1GC 심화 내용을 보고 다시 읽으면 이해가 쉬울 것이다.
  >
  > 1. Young GC 시작시 모든 Eden Region과 Survivor Region으로 CSet을 구성한다.
  > 2. GC Root에서 시작하는 객체 참조 그래프를 추적하여 CSet 내 객체에 도달하면 해당 객체는 즉시 새로운 Region으로 복사한다.
  > 3. CSet에 포함된 각 Region의 RSet을 스캔하여 Old Region에서 참조하는 객체를 발견하면, 해당 객체 또한 즉시 새로운 Region으로 복사한다. (2, 3번 병렬 수행)
  > 4. 모든 생존 객체 복사가 완료되면, CSet에 포함되었던 기존 Region들을 통째로 회수(Reclaim)하여 비운다.
  >
  > 정지 시간(STW)은 발생하지만, 대상 Region 수가 많지 않아 STW 시간은 짧다.

- **중요한 부가 동작**  
   Young GC가 실행되면, G1은 **Old 영역을 수집할 준비로서 Concurrent Marking 사이클을 시작**한다.  
   이 신호가 다음 단계로 이어진다.
  > #### **언제 Concurrent Marking이 시작되나?**
  >
  > - G1GC는 Old 영역의 사용량이 특정 임계치를 넘으면 Concurrent Marking 사이클을 시작한다.
  > - 이 임계치는 `-XX:InitiatingHeapOccupancyPercent` (기본값 45%)로 설정된 전체 힙 대비 Old 영역 점유율이다.
  >   - 예: 전체 힙의 45% 이상이 Old로 차면, 이후 발생하는 Young GC 한 번에 Initial Mark가 포함되어 함께 실행된다.
  >
  > #### **왜 Young GC가 실행된 STW에서 Concurrent Marking을 시작 할까?**
  >
  > - Young GC가 STW를 수행하므로, Initial Mark는 별도의 STW를 발생시키지 않고 이 STW를 재활용한다.
  > - Young GC 과정에 어차피 GC Root를 스캔하는 작업이 포함되어 있으므로, **이 스캔 과정을 함께 활용**하여 Initial Mark 작업을 효율적으로 수행한다.

### 2단계: Concurrent Marking Cycle (애플리케이션과 병행 진행)

이 단계는 대부분 **STW 없이 애플리케이션과 동시에 진행**되며,  
Old 영역의 객체들 중 어떤 것이 살아 있고, 어떤 것이 회수 가능한지를 백그라운드에서 분석하는 과정이다.

#### 세부 단계

1. **Initial Mark**  
   Young GC의 STW에 짧게 끼워 넣어, GC Root에서 직접 참조 중인 객체를 빠르게 마킹한다.

   > Initial Mark 종료 시점에 생존해 있는 객체는 무슨일이 있어도 생존 해야 한다.

2. **Concurrent Marking**  
   STW 없이, 애플리케이션 실행과 동시에 전체 힙을 스캔하며 살아 있는 객체를 탐색한다.  
   가장 오래 걸리는 단계지만, 병행 처리되기 때문에 애플리케이션에 큰 영향을 주지 않는다.

   > 자세한 과정은 G1GC 심화 내용을 확인

3. **Remark**  
   마킹 중 변경된 객체 참조를 반영하기 위해 짧은 STW가 발생한다.  
   이 단계에서 **정확한 생존 객체 정보가 최종 확정**된다.

   > - SATB Buffer에 있는 객체를 모두 marking한다.
   > - GC Root를 처음부터 다시 빠르게 훑어서, 누락된 객체 marking 한다.

4. **Cleanup**  
   Remark에서 수집한 마킹 정보를 바탕으로 실행된다.  
   Live Ratio가 0%인 Region은 즉시 메모리를 반납하고, 나머지 Old Region은 Mixed GC 후보로 정리된다.  
   객체 이동 없이 메모리를 회수하므로, 이 단계는 GC라기보단 정리에 가깝다.

> **결과**: 이 과정을 통해 G1은 "어떤 Old Region이 Garbage로 가득 차 있는지"에 대한 정확한 정보를 확보하게 된다.

### 3단계: Mixed GC (STW 발생)

Concurrent Marking이 완료되면, G1은 Old 영역을 본격적으로 수집할 준비가 된다.  
이때 실행되는 것이 바로 G1GC의 핵심인 **Mixed GC**다.

> Mixed GC는 반드시 **Concurrent Marking 사이클이 성공적으로 완료된 이후에만 실행 가능**하다.

#### 특징 및 전략

- **무엇을 수집하나?**  
  모든 Young Region과 함께,  
  **Garbage 비율이 높은 일부 Old Region**도 동시에 수집한다.

- **Garbage-First 전략**  
  G1은 수집 우선순위를 **살아 있는 객체 비율(Live Ratio)** 낮은 순으로 정렬해,  
  **가장 수거 효율이 높은 Region부터 수집 대상으로 포함**한다.

- **정지 시간 제어**  
  사용자가 설정한 목표 정지 시간(`-XX:MaxGCPauseMillis`)을 지키기 위해,  
  이번 GC에서 수집할 Old Region 수를 자동 조정한다.

- **여러 번 반복 수행**  
  전체 Old 영역을 한 번에 정리하지 않고,  
  여러 번의 Mixed GC를 통해 점진적으로 수집을 수행한다.

> **핵심 전략**:  
> Full GC처럼 모든 영역을 한꺼번에 정리하지 않고,  
> **짧은 STW를 반복**하면서 Young GC처럼 보이는 타이밍에 Old 영역도 조금씩 정리해 나간다.

### 4단계: 최후의 보루 - Full GC

G1GC는 가능한 한 Full GC를 피하도록 설계되어 있지만,  
다음과 같은 상황에서는 전체 힙을 정지하고 정리해야 한다.

#### 발생 조건

- Humongous 객체 할당 실패
- Old Region 증가 속도가 Mixed GC 처리 속도를 초과
- 내부 메타데이터 구조 이상 등 비정상 상태 발생

#### 특징

- 전체 Heap을 STW 상태에서 정리하며, **압축(compaction)** 까지 수행한다.
- Full GC는 가장 비용이 크고 긴 작업이므로,  
  **자주 발생한다면 튜닝이 반드시 필요한 신호**다.

> 특히 G1GC는 **Humongous 객체를 연속된 Region에만 할당할 수 있기 때문에**,  
> Heap 공간이 충분하더라도 **연속된 빈 Region이 없으면 Full GC가 발생**할 수 있다.  
> 이 경우에는 **Region 크기를 조절하거나, Humongous 객체 생성을 줄이는 전략**이 필요하다.

### GC 사이클 전체 요약

| 단계                   | 설명                                         | STW 여부                 |
| ---------------------- | -------------------------------------------- | ------------------------ |
| **Young GC**           | Eden/Survivor 수집. Copying 기반의 Minor GC  | 있음 (짧음)              |
| **Concurrent Marking** | Old 영역을 위한 생존 객체 분석               | 대부분 없음              |
| **Mixed GC**           | Young + 일부 Old Region 동시 수집. 반복 수행 | 있음 (목표 시간 내 조절) |
| **Full GC**            | 전체 Heap 정리 및 압축                       | 있음 (가장 비용 큼)      |

---

## 5. Mixed GC 도중 Old 영역이 포화될 때 필요한 튜닝

Mixed GC가 끝나기 전에 Old 영역이 점점 차오르고, 결국 Full GC까지 발생하는 경우가 있다면, 이는 G1GC 튜닝이 필요하다는 신호이다.

이런 상황은 다음과 같은 원인으로 발생한다:

- Concurrent Marking에서 가비지를 많이 식별했지만,
- G1이 `G1MixedGCCountTarget` 횟수 안에 수집을 끝내지 못하거나,
- `MaxGCPauseMillis` 제한 때문에 한 번에 충분히 많은 Region을 회수하지 못하는 경우

이럴 때 조정해야 할 대표적인 옵션은 다음과 같다.

### 주요 튜닝 항목 요약

| 옵션                                  | 설명                                                           | 기본값 (Java 8 기준) | 조정 예시                                 |
| ------------------------------------- | -------------------------------------------------------------- | -------------------- | ----------------------------------------- |
| `-XX:G1MixedGCCountTarget`            | 한 번의 Concurrent Cycle 이후 Mixed GC 반복 횟수 목표          | 8                    | 12~16 등으로 증가시켜 수집을 분산시킨다   |
| `-XX:G1HeapWastePercent`              | 얼마나 많은 쓰레기가 있으면 수집할지 기준                      | 5                    | 5 → 2로 낮추면 더 적극적으로 청소한다     |
| `-XX:G1OldCSetRegionThresholdPercent` | Mixed GC 1회당 Old Region 최대 수 (비율 기준)                  | 10                   | 10 → 15~20 등으로 확장한다                |
| `-XX:MaxGCPauseMillis`                | 각 GC 사이클의 목표 정지 시간(ms)                              | 200                  | 250~300 등으로 완화하면 수집량이 늘어난다 |
| `-XX:InitiatingHeapOccupancyPercent`  | 전체 힙 대비 얼마나 찼을 때 Concurrent Marking을 시작할지 결정 | 45                   | 30~35 등으로 낮추면 더 빨리 시작된다      |

### 튜닝 전략 요약

- 수집 횟수가 부족하다면  
  → `G1MixedGCCountTarget` 값을 늘려야 한다

- 수집량이 부족하다면  
  → `MaxGCPauseMillis`를 높이고  
  → `G1OldCSetRegionThresholdPercent`도 함께 높이면 좋다

- Marking이 너무 늦게 시작된다면  
  → `InitiatingHeapOccupancyPercent` 값을 낮춰서 조기 시작을 유도한다

- Garbage 판단 기준이 너무 엄격하다면  
  → `G1HeapWastePercent` 값을 낮춰 더 많은 Region을 수집 대상으로 포함시킨다

### 예시 상황

Concurrent Marking 이후, Old Region 후보가 300개이고  
`G1MixedGCCountTarget=8`이며  
한 번에 20개씩만 수집할 수 있다면  
총 160개만 수집되고, 나머지 140개는 남게 된다.

이 경우 Heap 압박이 계속 증가하게 되므로  
위 튜닝 항목을 조정하여 회수 효율을 개선해야 한다.

### Full GC로 가는 징후

- GC 로그에 `Full GC`가 자주 나타난다
- `to-space exhausted`, `promotion failure`, `humongous allocation failed` 등의 메시지가 등장한다
- Old 영역이 Mixed GC 이후에도 계속 커지고 있다

이런 징후가 있다면 위 옵션들을 반드시 점검해야 한다.
