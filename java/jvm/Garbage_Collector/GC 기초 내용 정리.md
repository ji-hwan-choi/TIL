# Garbage Collector 기초 내용 정리

## 1. 가바지 컬렉터(GC)가 왜 필요한가?

Java는 자동 메모리 관리 언어이다.  
C 언어 같은 경우에는 malloc()과 free()로 메모리를 직접 할당하고 해제해야 한다.  
하지만 Java는 객체를 new로 생성하기만 하면, **필요 없어졌을 때 자동으로 삭제(GC)** 해준다.

- 장점
  - 개발자가 메모리 해제를 깜빡해서 생기는 **메모리 누수(leak)** 를 줄여줌
  - 이미 해제된 메모리를 접근해서 생기는 심각한 오류를 방지함

> 이 자동 청소를 **가비지 컬렉터(Garbage Collector)** 가 수행한다.

---

## 2. Heap 영역의 내부 구조

> GC는 JVM 메모리 구조 중, **Heap 영역만 관리** 한다.

### Heap 영역의 두 영역

- **Young Generation**
  - 새로 생성된 객체가 들어가는 영역
- **Old Generation**
  - 오래 살아남은 객체가 이동되는 영역

### Young Generation 세부 구분

- Eden
  - 객체가 처음 생성되는 공간
- Survivor 0 (S0)
  - Eden에서 살아남은 객체가 이동하는 임시 공간
- Survivor 1 (S1)
  - 다음 GC 때 S0 ↔ S1 역할이 바뀜 (Ping-Pong 구조)

> ### Survivor는 왜 2개일까?
>
> 1.`new`로 객체 A, B, C를 생성 → **Eden에 저장**  
> 2. GC 발생 → 살아있는 A, B는 **S0으로 이동**, C는 삭제  
> 3. 다음 GC 발생:  
> \- S0에 있는 A, B가 살아있음  
> \- 이 객체는 S1으로 복사  
> \- 이번엔 S1이 살아남은 객체 저장소가 됨  
> \- S0은 비워짐  
> 이렇게 S0과 S1이 번갈아 가며 사용되면서, 살아있는 객체만 점점 Old로 이동하게 되는 구조이다.
>
> GC가 반복되며 살아남은 객체는 <strong>나이(Age)</strong>가 증가하고, 일정 나이가 되면 <strong>Old로 승격(Promotion)</strong>된다.

### Survivor 영역(S0, S1)의 구조와 역할

**1. Eden → Survivor 이동 과정**  
객체가 생성되면 처음에는 항상 Eden 영역에 저장된다.  
하지만 Eden은 크기가 작기 때문에, 곧 Minor GC가 발생하고 살아있는 객체만 Survivor로 이동된다.  
그때 사용하는 구조가 바로:

- Survivor 0 (S0)
- Survivor 1 (S1)

> 두 Survivor는 **Ping-Pong** 구조로 동작한다.  
> 한쪽은 From, 한쪽은 To로 사용됨. GC 이후에는 역할을 교체한다.
> 한쪽은 반드시 공간이 아예 비워져 있어야 한다.

**2. 왜 Survivor 영역이 2개일까?**  
**Eden → S0 (From) → S1 (To)** 로 객체를 반복적으로 복사하는 구조는 객체 생존 여부를 계속 추적하고,  
점진적으로 **Old 영역으로 이동시킬 객체를 선별**하기 위한 전략이다.  
1개의 Survivor만 있으면 복사 대상과 복사 저장소가 충돌하므로 무조건 2개가 필요하다.

---

## 3. GC의 개입 시점과 대상

### GC는 언제 작동 할까?

- Eden 공간이 꽉 찼을 때 → **Minor GC**
- Old 영역까지 꽉 찼을 때 → **Major / Full GC**

### GC가 작동할 때 어떤 일이 생길까? (Stop-The-World)

GC가 자신의 역할을 수행하기 위해, JVM은 애플리케이션 실행을 일시적으로 멈춘다.  
이를 **'Stop-The-World(STW)'** 라고 부른다.

STW는 GC 관련 스레드를 제외한 모든 스레드의 작업을 중단시키는 것으로, 이 시간 동안 애플리케이션은 완전히 멈춘다. 따라서 STW 시간이 길어질수록 사용자는 성능 저하를 체감하게 된다.

- **Minor GC의 STW**: 일반적으로 매우 짧다 (수 ms ~ 수십 ms). 그래서 거의 인지하기 어렵다.
- **Major/Full GC의 STW**: 처리할 데이터가 많아 훨씬 길다 (수백 ms ~ 수 초). 이 STW가 바로 성능 문제의 주범이 되는 경우가 많다.

> 현대 GC의 발전 방향은 바로 이 STW 시간을 줄이는 것에 초점이 맞춰져 있다.

### GC는 어떤 객체를 지울까?

- **현재 어떤 변수/객체도 참조하지 않는 객체**는 사용 불가능 → 제거 대상
- 이에 대한 판단은, JVM은 항상 어떤 객체들이 **GC Root**에서부터 연결되어 있는지를 탐색한다.

---

## 4. 객체의 Age 와 Old 영역으로의 이동

**1. 객체의 "Age"란?**  
 GC 과정에서 객체가 몇 번 살아남았는지를 나타내는 숫자이다.  
이 값은 JVM 내부적으로 **객체 헤더(Object Header)** 에 저장된다.

- Java 객체는 일반적으로 2-Word Header 구조를 가진다.
  - Mark Word: HashCode, **GC Age**, Lock 정보 등
  - Class Pointer: 클래스 메타데이터에 대한 포인터

**2. Age 저장 방식**

- Mark Word의 일부 비트를 활용하여 Age 정보를 저장
- JVM은 이 Age 값을 참조하여, 특정 나이가 되면 Old 영역으로 승격시킨다.

> ### 몇 번 살아남아야 Old영역으로 이동(Promotion) 될까?
>
> **기본값은 15번 이다.** 정확히 말하면
>
> - `-XX:MaxTenuringThreshold` 옵션의 기본값은 15
> - 이는 객체가 15번 Minor GC에서 살아남으면 Old로 승격된다는 뜻
>
> 하지만 JVM은 이 값을 동적으로 조정한다.  
> 특정 조건이 되면 아래와 같은 변화가 생긴다:
>
> #### 동적 승격: Early Promotion
>
> **1. Survivor 영역이 꽉 찼을 경우**  
>  만약 S0 또는 S1이 가득 차서 **살아남은 객체를 수용할 수 없는 경우**,  
>  아직 Age가 낮은 객체라도 강제로 Old로 승격시킨다. 이를 **"Early Promotion"** 또는 **"Premature Promotion"** 이라 부른다.  
> **2. 동적 임계값 조절 (Dynamic Tenuring Threshold)**  
>  JVM은 Survivor 내 객체들의 Age 분포를 통계적으로 분석하여, `MaxTenuringThreshold`에 도달하기 전에 승격 임계값을 동적으로 낮출 수 있다.  
> 예를 들어, 특정 Age의 객체들이 차지하는 메모리량이 Survivor 영역의 특정 비율(`-XX:TargetSurvivorRatio`, 기본값 50%)을 초과하면, 다음 GC부터 해당 Age를 새로운 승격 임계값으로 삼아 조기에 객체를 승격시킨다.  
> **3. 객체의 크기가 매우 클 경우 (Allocation Promotion)**  
> 만약 생성하려는 객체의 크기가 Eden 영역이나 Survivor 영역의 가용 공간보다 크다면, 이 객체는 Young Generation을 거치지 않고 곧바로 Old Generation에 할당된다.  
> 이는 비효율적인 Minor GC를 방지하기 위한 최적화이다.

---

## 5. GC의 동작 원리: Generation에 따른 다른 전략

GC는 객체의 수명과 메모리 영역의 특성에 따라 가장 효율적인 방식으로 동작한다. 따라서 Young Generation과 Old Generation은 서로 다른 원리를 사용한다.

**1. Young Generation: 빠르고 효율적인 'Mark and Copy'**  
 Young Generation에서 발생하는 Minor GC는 '**Mark and Copy**' 알고리즘을 사용한다.  
 이는 대부분의 객체가 금방 쓰레기가 된다는 가설(Weak Generational Hypothesis)에 최적화된 방식이다.

1. **Mark (표시)**: Eden 영역과 From-Survivor 영역에 있는 객체 중, GC Root로부터 도달 가능한 살아있는 객체들을 모두 표시한다.
2. **Copy (복사)**: 표시된 객체들을 비어있는 **To-Survivor 영역으로 복사**한다. 이 과정에서 객체의 Age는 1 증가하며, 메모리는 새로운 위치에 순서대로 쌓이므로 **자연스럽게 단편화가 해소(Compaction)** 된다.
3. **Clear (정리)**: 복사가 끝나면, 기존의 **Eden과 From-Survivor 영역에 남아있는 모든 객체(쓰레기)를 무시하고 영역 전체를 한 번에 깨끗하게 비운다.**

이 방식은 살아남는 객체가 적은 Young Generation에서 매우 빠르고 효율적이다.

**2. Old Generation: 신중하고 철저한 'Mark-Sweep-Compact'**  
Old Generation은 오랫동안 살아남은 객체들이 모여있어, 살아있는 객체의 비율이 높다. 이런 상황에서 'Copy' 방식은 비효율적이므로, 전통적인 **'Mark-Sweep-Compact'** 알고리즘을 사용한다.

1. **Mark (표시)**: Old Generation에 있는 객체 중, GC Root에서부터 참조 연결이 살아있는 객체를 모두 표시한다.
2. **Sweep (수거)**: 표시되지 않은 객체, 즉 쓰레기를 메모리에서 제거한다. 이 단계가 끝나면 메모리 중간중간에 구멍(빈 공간)이 생기는 **'메모리 단편화'** 가 발생할 수 있다.
3. **Compact (압축)**: 메모리 단편화를 해결하기 위해, 살아있는 객체들을 한쪽으로 차곡차곡 이동시켜 빈 공간을 최소화한다. 이 과정은 비용이 크기 때문에 모든 GC에서 항상 수행되지는 않을 수 있다.

   > 메모리 단편화란?  
   > 할당과 해제가 반복되면서 사용 가능한 메모리가 조각(junk)처럼 흩어지는 현상이다.  
   > 전체 빈 공간의 크기는 충분하지만, **연속된 큰 공간이 없어서 큰 객체를 할당할 수 없는 상태**를 말한다.

### GC Root란 무엇인가?

GC Root(Garbage Collection Root)란, 가비지 컬렉터(GC)가 **'도달 가능한(Reachable)' 객체**인지 아닌지를 판단하는 데 기준이 되는 시작점 객체들의 집합을 의미한다.

JVM의 메모리 관리에서 어떤 객체가 '살아있는' 객체인지, 아니면 아무도 참조하지 않는 '쓰레기'인지를 판별하기 위해, GC는 GC Root로부터 시작하는 객체 참조 그래프를 순회한다. 이 순회 과정에서 도달할 수 있는 모든 객체는 '살아있는' 객체로 간주되며, 그렇지 않은 객체는 수거 대상이 된다.

- **GC Root가 될 수 있는 주요 대상**
  - 실행 중인 스레드의 스택 변수 (Local Variables)
    - 스택 프레임 내에서 선언된 지역 변수나 메소드 파라미터 등이 참조하는 객체들은 가장 대표적인 GC Root이다.  
      해당 메소드가 실행되는 동안에는 반드시 살아있어야 하기 때문이다.
  - 정적 변수 (Static Variables)
    - 정적 변수는 메소드 영역(또는 Metaspace)에 저장되며, 클래스가 JVM에 로드되어 있는 동안에는 항상 메모리에 상주한다.  
      따라서 프로그램 실행 전반에 걸쳐 GC의 기준점이 된다.
  - JNI 참조 (Java Native Interface References)
    - 자바가 아닌 네이티브 코드(C, C++ 등)에서 JNI를 통해 생성되었거나 참조하는 자바 객체들.
    - 네이티브 코드가 해당 객체를 사용하고 있을 수 있으므로, GC는 이를 임의로 수거할 수 없다.
  - 기타
    - JVM 자체적인 목적을 위해 유지하는 객체(e.g., 시스템 클래스 로더)나 동기화(Synchronization)에 사용되는 락(Lock) 객체 등도 GC Root로 간주될 수 있다.

---

## 그래서 GC가 뭔데?

**살아있는 객체**를 안전한 공간으로 잘 이동한 다음 남아있는 공간을 전부 비워두는 과정이다.  
사실은 Garbage 보다, **살아있는(Reachable) 객체에게 더 관심이 많다.**  
Marking도 살아있는 객체를 찾기 위해서 하는 행위이다.
