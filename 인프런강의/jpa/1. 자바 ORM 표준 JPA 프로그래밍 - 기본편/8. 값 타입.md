## JPA 데이터 타입 분류

JPA의 데이터 타입은 크게 **엔티티(Entity) 타입**과 **값(Value) 타입**으로 나뉜다.

- **엔티티 타입**: `@Entity` 어노테이션으로 정의하는 객체이다. 식별자(Identifier)를 가지고 있어 데이터가 변경되어도 지속적으로 추적이 가능하다. 예를 들어, 회원의 나이나 이름이 변경되어도 식별자를 통해 같은 회원임을 인식할 수 있다.
- **값 타입**: `int`, `String`처럼 값으로 사용하는 자바 기본 타입이나 객체를 의미한다. 식별자가 없으므로 값을 변경하면 완전히 다른 값으로 대체되어 추적이 불가능하다.

---

## 값 타입의 종류

값 타입은 세 가지로 분류할 수 있다.

1.  **기본값 타입**: `int`, `Integer`, `String` 등 자바가 기본적으로 제공하는 타입이다. 생명주기를 엔티티에 의존하며, 공유되어서는 안 된다.
2.  **임베디드 타입 (복합 값 타입)**: 여러 기본값 타입을 묶어 새로 정의한 값 타입이다.
3.  **값 타입 컬렉션**: 값 타입을 하나 이상 저장할 때 사용하는 컬렉션이다.

---

## 임베디드 타입 (Embedded Type)

여러 연관된 속성을 하나의 값 타입으로 묶어 재사용성과 응집도를 높이는 방법이다. JPA에서는 이를 임베디드 타입이라 하며, `@Embeddable`과 `@Embedded` 어노테이션을 사용해 정의하고 사용한다.

- `@Embeddable`: 값 타입을 정의하는 클래스에 붙인다.
- `@Embedded`: 값 타입을 사용하는 필드에 붙인다.
- **규칙**: 임베디드 타입은 반드시 기본 생성자를 가져야 한다.

임베디드 타입을 사용해도 매핑되는 데이터베이스 테이블의 구조는 바뀌지 않는다. 임베디드 타입의 필드들이 그대로 상위 엔티티의 테이블 컬럼으로 매핑된다.

### 예시 코드: 주소 임베디드 타입

`Address`라는 값 타입을 정의하고, `Member` 엔티티에서 사용하는 예시이다.

```java
// 값 타입을 정의하는 클래스
@Embeddable
public class Address {

    private String city;
    private String street;
    private String zipcode;

    // JPA 스펙상 기본 생성자는 필수이다.
    protected Address() {
    }

    public Address(String city, String street, String zipcode) {
        this.city = city;
        this.street = street;
        this.zipcode = zipcode;
    }
    // Getter...
}

// 값 타입을 사용하는 엔티티
@Entity
public class Member {

    @Id
    @GeneratedValue
    private Long id;

    private String name;

    // homeAddress 필드에 Address 타입을 임베디드함
    @Embedded
    private Address homeAddress;
}
```

위 코드는 아래와 같이 `MEMBER` 테이블에 매핑된다. `Address`의 필드들이 `Member` 엔티티의 일부처럼 매핑되는 것을 볼 수 있다.

- **MEMBER 테이블**: `ID`, `NAME`, `CITY`, `STREET`, `ZIPCODE`

### 속성 재정의: @AttributeOverride

만약 한 엔티티에서 같은 임베디드 타입을 여러 개 사용하면 컬럼명이 중복되는 문제가 발생한다. 예를 들어, `homeAddress`와 `workAddress`를 모두 `Address` 타입으로 가지는 경우이다. 이때 `@AttributeOverrides`와 `@AttributeOverride`를 사용해 컬럼명을 재정의할 수 있다.

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @Embedded
    private Address homeAddress;

    // workAddress의 컬럼명을 재정의한다.
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name="city", column=@Column(name="WORK_CITY")),
        @AttributeOverride(name="street", column=@Column(name="WORK_STREET")),
        @AttributeOverride(name="zipcode", column=@Column(name="WORK_ZIPCODE"))
    })
    private Address workAddress;
}
```

---

## 값 타입과 불변 객체

값 타입의 인스턴스를 여러 엔티티가 공유하면 **부작용(Side Effect)** 이 발생할 수 있다.

```java
// 1. 주소 인스턴스 생성
Address address = new Address("서울", "강남대로", "12345");

// 2. member1과 member2가 같은 주소 인스턴스를 참조
Member member1 = new Member();
member1.setHomeAddress(address);
entityManager.persist(member1);

Member member2 = new Member();
member2.setHomeAddress(address);
entityManager.persist(member2);

// 3. member1의 주소 도시만 바꾸려 했으나...
// 참조를 공유하고 있으므로 member2의 도시까지 함께 변경된다.
member1.getHomeAddress().setCity("부산");
```

이러한 문제를 해결하기 위해 값 타입은 **불변 객체(Immutable Object)** 로 설계해야 한다. 불변 객체는 생성 시점 이후에 내부의 값을 절대 변경할 수 없는 객체를 말한다. 생성자를 통해서만 값을 설정하고, 값을 변경할 수 있는 수정자(Setter)를 만들지 않으면 된다.

### 예시 코드: 불변 Address 클래스

`Address` 클래스에서 Setter를 제거하여 불변성을 보장한다.

```java
@Embeddable
public class Address {

    private String city;
    private String street;
    private String zipcode;

    protected Address() {
    }

    // 생성자를 통해서만 값을 할당한다.
    public Address(String city, String street, String zipcode) {
        this.city = city;
        this.street = street;
        this.zipcode = zipcode;
    }

    // Setter를 제공하지 않아 값 변경을 막는다.
    public String getCity() { return city; }
    public String getStreet() { return street; }
    public String getZipcode() { return zipcode; }

    // equals와 hashCode 메소드를 재정의하여 값 비교가 가능하게 한다.
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Address address = (Address) o;
        return java.util.Objects.equals(city, address.city) &&
               java.util.Objects.equals(street, address.street) &&
               java.util.Objects.equals(zipcode, address.zipcode);
    }

    @Override
    public int hashCode() {
        return java.util.Objects.hash(city, street, zipcode);
    }
}
```

값을 변경해야 할 때는 기존 인스턴스를 수정하는 대신, 새로운 값을 가진 인스턴스를 생성해서 교체해야 한다.

---

### 값 타입의 비교 (Comparing Value Types)

값 타입은 식별자 없이 속성 값 자체로 의미를 가지므로, 인스턴스가 달라도 속성 값이 모두 같다면 '같은 값'으로 취급해야 한다. 이를 위해 자바의 객체 비교 방식인 동일성과 동등성을 명확히 이해해야 한다.

- **동일성(Identity)**: `==` 연산자를 사용하며, 두 객체의 메모리 주소 값이 같은지를 비교한다. 서로 다른 인스턴스는 항상 `false`를 반환한다.
- **동등성(Equivalence)**: `equals()` 메소드를 사용하며, 두 객체의 내부 값이 같은지를 비교한다. 값 타입은 동등성 비교를 해야 하므로, `equals()` 메소드를 재정의(Override)해야 한다.

```java
// 두 Address 인스턴스는 서로 다른 메모리 주소를 가진다.
Address a = new Address("서울", "강남", "12345");
Address b = new Address("서울", "강남", "12345");

// 동일성 비교 (메모리 주소 비교) -> false
System.out.println(a == b);

// 동등성 비교 (내부 값 비교) -> true (equals를 재정의했을 경우)
System.out.println(a.equals(b));
```

따라서 임베디드 타입 같은 값 타입을 직접 정의할 때는, 모든 속성 값을 비교하여 동등성을 판단하도록 `equals()` 메소드를 재정의하는 것이 필수적이다. `equals()`를 재정의했다면 `hashCode()`도 반드시 함께 재정의해야 한다.

---

### 값 타입 컬렉션 (Value Type Collections)

회원이 좋아하는 음식 여러 개나, 주소 변경 이력처럼 특정 값 타입이 하나 이상 필요할 때 값 타입 컬렉션을 사용한다. `@ElementCollection`과 `@CollectionTable` 어노테이션을 통해 매핑하고, 값 타입 컬렉션은 별도의 테이블에 저장된다.

- **생명주기**: 값 타입 컬렉션은 해당 컬렉션을 소유한 엔티티와 생명주기가 같다. 즉, 부모 엔티티가 저장될 때 함께 저장되고, 삭제될 때 함께 삭제된다. 이는 엔티티 관계의 `cascade = CascadeType.ALL`과 `orphanRemoval = true` 옵션을 적용한 것과 같다.
- **지연 로딩**: 성능 최적화를 위해 기본적으로 지연 로딩(Lazy Loading) 방식으로 동작한다.

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;

    // ...

    @ElementCollection
    @CollectionTable(name = "ADDRESS_HISTORY", // 별도 테이블 지정
        joinColumns = @JoinColumn(name = "MEMBER_ID") // 부모 엔티티와 조인할 컬럼
    )
    private List<Address> addressHistory = new ArrayList<>();
}
```

위 코드를 실행하면 `MEMBER` 테이블 외에 `ADDRESS_HISTORY` 테이블이 생성되며, 이 테이블은 `MEMBER_ID`를 외래 키로 가진다.

---

### 값 타입 컬렉션의 치명적 단점과 대안

값 타입 컬렉션은 사용하기 편리해 보이지만, 실무에서 사용하기에는 매우 위험한 단점을 가지고 있다.

#### **문제점: 비효율적인 업데이트 방식**

값 타입 컬렉션에 포함된 값 타입들은 식별자 개념이 없다. 이 때문에 컬렉션의 요소 하나를 수정하거나 추가, 삭제할 때 JPA는 어떤 요소가 변경되었는지 추적하지 못한다.

결과적으로 JPA는 컬렉션에 변경이 발생하면, **해당 엔티티에 연관된 모든 컬렉션 데이터를 데이터베이스에서 삭제하고, 현재 컬렉션에 있는 모든 값을 다시 삽입**하는 방식을 사용한다.

예를 들어, 주소 이력이 10개 있는 회원의 주소 하나를 수정하면 다음과 같은 쿼리가 발생한다.

1.  **DELETE FROM ADDRESS_HISTORY WHERE MEMBER_ID = ?** (해당 회원의 주소 이력 10개 모두 삭제)
2.  **INSERT INTO ADDRESS_HISTORY (...) VALUES (...)** (수정된 내용을 포함한 10개의 주소를 다시 삽입)

이는 엄청난 성능 저하를 유발하며, 운영 환경에서 심각한 문제를 일으킬 수 있다.

#### **대안: 일대다(One-to-Many) 관계로 해결**

이러한 문제를 해결하는 가장 좋은 방법은 값 타입 컬렉션을 사용하는 대신, 별도의 **엔티티**로 승격시켜 일대다 관계로 매핑하는 것이다.

```java
// 1. Address를 값 타입이 아닌 별도의 엔티티로 정의한다.
@Entity
public class AddressEntity {
    @Id @GeneratedValue
    private Long id; // 고유 식별자를 가진다.

    @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;

    private String city;
    private String street;
    private String zipcode;

    // ... 생성자, Getter 등
}

// 2. Member 엔티티에서는 AddressEntity와 일대다 관계로 매핑한다.
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;

    // ...

    // cascade와 orphanRemoval 옵션으로 생명주기를 Member에 종속시킨다.
    @OneToMany(mappedBy = "member", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<AddressEntity> addressHistory = new ArrayList<>();
}
```

이렇게 `AddressEntity`라는 별도의 엔티티를 만들면, 각 주소 이력은 고유한 `id` 값을 가지게 된다. 덕분에 JPA는 각 레코드를 명확하게 추적하여 수정이 필요한 레코드만 `UPDATE` 하거나, 특정 레코드만 `DELETE` 하는 등 훨씬 효율적인 쿼리를 실행할 수 있다. `cascade = CascadeType.ALL`과 `orphanRemoval = true` 옵션을 통해 값 타입 컬렉션처럼 생명주기를 부모 엔티티에 종속시킬 수도 있다.

---

### 정리: 언제 무엇을 써야 하는가?

- **값 타입**: 추적이 필요 없는 단순한 값의 묶음일 때 사용한다. 예를 들어, 회원의 주소나 배송지의 주소처럼 그 자체가 독립적인 의미보다는 특정 엔티티의 속성으로만 의미가 있을 때 적합하다.
- **엔티티**: 식별자가 필요하고, 변경 사항을 지속해서 추적 및 관리해야 한다면 값 타입이 아닌 엔티티로 만들어야 한다. 특히 값의 **컬렉션**이 필요하다면, 성능 이슈를 피하기 위해 값 타입 컬렉션 대신 일대다 관계의 엔티티로 만드는 것이 현명한 선택이다.
