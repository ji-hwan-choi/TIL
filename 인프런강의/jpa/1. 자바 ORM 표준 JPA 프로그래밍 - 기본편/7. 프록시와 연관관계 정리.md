## JPA 심화: 프록시와 연관관계 관리

JPA를 사용하면 객체와 관계형 데이터베이스의 테이블을 매끄럽게 매핑할 수 있다.  
하지만 단순히 매핑하는 것을 넘어, 애플리케이션의 성능을 최적화하기 위해서는 연관된 객체들을 언제, 어떻게 데이터베이스에서 불러올지 관리하는 것이 매우 중요하다.

**프록시(Proxy)** 의 개념과 동작 방식, 그리고 연관된 엔티티의 로딩 전략을 결정하는 **즉시/지연 로딩**에 대해 알아본다.  
또한, 엔티티의 생명주기를 편리하게 관리하는 **영속성 전이(Cascade)** 와 **고아 객체(Orphan Removal)** 개념까지 깊이 있게 다룬다.

---

### 1. 프록시(Proxy): 필요한 순간에만 로딩하는 가짜 객체

애플리케이션 로직상 `Member` 엔티티의 정보만 필요하고, 연관된 `Team` 엔티티의 정보는 필요 없는 경우가 많다. 이럴 때 `Member`를 조회하기 위해 `Team`까지 항상 데이터베이스에서 함께 조회하는 것은 상당한 자원 낭비이다.

JPA는 이런 비효율을 해결하기 위해 **프록시**라는 기술을 사용한다. 프록시는 실제 엔티티 객체를 대신하는 가짜 객체로, 실제 데이터가 필요한 시점까지 데이터베이스 조회를 미루는 역할을 한다.

#### **`em.find()` vs `em.getReference()`**

JPA에서 엔티티를 조회하는 방식은 크게 두 가지이며, 이를 통해 프록시의 개념을 이해할 수 있다.

- `em.find()`: 데이터베이스를 즉시 조회하여 **실제 엔티티 객체**를 반환한다.
- `em.getReference()`: 데이터베이스 조회를 미루고, 해당 엔티티를 가리키는 **프록시(가짜) 엔티티 객체**를 반환한다.

<!-- end list -->

```java
// DB를 즉시 조회하여 실제 Member 엔티티를 가져옴
Member member1 = em.find(Member.class, 1L);

// DB 조회를 미루고 프록시 Member 객체를 가져옴
// SELECT 쿼리가 실행되지 않음
Member member2 = em.getReference(Member.class, 2L);
```

#### **프록시의 동작 원리**

1.  **상속과 위임**: 프록시 객체는 실제 엔티티 클래스를 상속받아 만들어지므로, 겉모습(메서드 시그니처 등)이 완전히 동일하다. 내부적으로는 실제 엔티티의 참조(`target`)를 가지고 있다. 처음에는 이 `target`이 비어있다.

2.  **초기화**: 개발자가 프록시 객체의 메서드를 호출하면(단, ID 값을 조회하는 `getId()`는 예외), 프록시는 실제 데이터가 필요하다고 판단한다.

    - 프록시는 영속성 컨텍스트에 실제 엔티티 생성을 요청하는 **초기화** 과정을 시작한다.
    - 영속성 컨텍스트는 데이터베이스를 조회하여 실제 엔티티를 생성한다.
    - 프록시는 생성된 실제 엔티티의 참조를 자신의 `target` 필드에 연결한다.
    - 마지막으로, 실제 엔티티(`target`)의 메서드를 호출하여 결과를 반환한다.

<!-- end list -->

```java
// 1. getReference() 호출 시점에는 SELECT 쿼리가 나가지 않음
Member member = em.getReference(Member.class, 1L);

// 2. member의 이름(ID 외의 값)을 사용하는 시점
String username = member.getName(); // 이 때 프록시가 초기화되며, SELECT 쿼리가 실행됨

System.out.println("사용자 이름: " + username);
```

#### **프록시의 주요 특징 및 주의사항**

- 프록시 객체는 처음 사용될 때 **한 번만 초기화**된다.
- 프록시가 초기화되어도 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 단지 실제 엔티티에 대한 참조를 통해 동작할 뿐이다.
- **타입 비교**: 프록시는 원본 엔티티를 상속한 별개의 클래스이므로, `==` 비교는 항상 `false`를 반환한다. 타입 비교는 반드시 `instanceof`를 사용해야 한다.
- **준영속 상태와 `LazyInitializationException`**: 영속성 컨텍스트가 종료되어 엔티티가 준영속(detached) 상태가 되면, 프록시를 초기화할 수 없다. 준영속 상태의 프록시 객체의 데이터를 조회하려고 시도하면 `org.hibernate.LazyInitializationException` 예외가 발생한다. 이는 실무에서 매우 흔하게 마주치는 문제이므로 반드시 이해해야 한다.
- **프록시 확인 및 강제 초기화**:
  - `PersistenceUnitUtil.isLoaded(entity)`: 프록시의 초기화 여부를 확인할 수 있다.
  - `entity.getClass()`: 프록시의 클래스 이름을 출력하여 프록시인지 확인할 수 있다(보통 `...$HibernateProxy$` 같은 이름이 포함됨).
  - `org.hibernate.Hibernate.initialize(entity)`: 프록시를 강제로 초기화할 수 있다.

---

### 2. 즉시 로딩(EAGER)과 지연 로딩(LAZY)

**지연 로딩(Lazy Loading)** 과 **즉시 로딩(Eager Loading)** 은 연관관계로 맺어진 엔티티를 언제 데이터베이스에서 조회할지를 결정하는 **페치(Fetch) 전략**이다. 이 전략은 앞서 설명한 프록시와 깊은 관련이 있다.

#### **지연 로딩 (Lazy Loading)**

- **개념**: 연관된 엔티티를 실제 사용하는 시점까지 조회하지 않고, 대신 그 자리에 **프록시 객체**를 넣어두는 전략이다.
- **동작**: `@ManyToOne(fetch = FetchType.LAZY)` 어노테이션을 사용한다. `Member`를 조회하면, `member.team` 필드에는 `Team`의 프록시 객체가 들어있다. 이후 `member.getTeam().getName()`처럼 실제 `Team` 객체를 사용할 때 데이터베이스 조회가 일어난다.
- **권장**: 성능 최적화와 불필요한 데이터 조회를 막기 위해 **모든 연관관계는 지연 로딩으로 설정하는 것이 기본 원칙**이다.

<!-- end list -->

```java
@Entity
public class Member {
    // ...
    @ManyToOne(fetch = FetchType.LAZY) // 지연 로딩으로 명시적 설정
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    // ...
}
```

#### **즉시 로딩 (Eager Loading)**

- **개념**: 엔티티를 조회할 때, 연관된 엔티티도 함께 **즉시** 데이터베이스에서 조회하는 전략이다.
- **동작**: `@ManyToOne(fetch = FetchType.EAGER)` 어노테이션을 사용한다. `Member`를 조회하면 JPA가 내부적으로 `LEFT OUTER JOIN` 등을 사용하여 `Team`까지 한 번의 SQL로 함께 조회한다. `member.team` 필드에는 프록시가 아닌 **실제 `Team` 객체**가 들어있다.

<!-- end list -->

```java
@Entity
public class Member {
    // ...
    @ManyToOne(fetch = FetchType.EAGER) // 즉시 로딩 설정
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    // ...
}
```

#### **실무에서의 페치 전략: 왜 항상 지연 로딩인가?**

**결론부터 말하면, 실무에서는 모든 연관관계에 지연 로딩(`FetchType.LAZY`)을 사용해야 한다.** 즉시 로딩은 사용하지 않는 것이 좋다.

- **예측 불가능한 SQL**: 즉시 로딩을 사용하면 개발자가 예상하지 못한 SQL이 실행될 수 있다. 특히 여러 엔티티가 복잡하게 얽혀있을 때, 하나의 엔티티를 조회하는 것이 수많은 조인을 유발하여 성능을 저하시킬 수 있다.
- **N+1 문제**: 즉시 로딩의 가장 심각한 문제이다. 예를 들어, `SELECT m FROM Member m`이라는 JPQL을 실행했다고 가정하자.
  1.  JPQL을 분석하여 `Member`를 조회하는 SQL이 실행된다 (1).
  2.  조회된 `Member`의 수(N개)만큼, 각 `Member`에 대해 연관된 `Team`을 조회하는 SQL이 추가로 N번 실행된다 (N).
  3.  결과적으로 총 **N+1**번의 쿼리가 발생하여 심각한 성능 저하를 일으킨다.
- **JPA 기본 페치 전략**:
  - `@ManyToOne`, `@OneToOne`: 기본값이 **즉시 로딩(EAGER)**이므로, 반드시 `LAZY`로 변경해주어야 한다.
  - `@OneToMany`, `@ManyToMany`: 기본값이 **지연 로딩(LAZY)**이다.

> **올바른 접근법**: 모든 연관관계를 `LAZY`로 설정하고, 특정 쿼리에서 연관된 엔티티를 함께 조회해야 할 때는 **JPQL의 페치 조인(fetch join)**이나 **엔티티 그래프(Entity Graph)** 기능을 사용하여 명시적으로 함께 가져오는 것이 가장 좋은 방법이다.

---

### 3. 영속성 전이(Cascade)와 고아 객체(Orphan Removal)

#### 영속성 전이(Cascade): 생명주기의 자동 전파

**영속성 전이**는 부모 엔티티에 발생하는 특정 생명주기 이벤트(`persist`, `remove` 등)를 자식 엔티티에게 그대로 **전파**시키는 기능이다. 핵심은 **'편의성'**이다. 이 기능이 없다면, 부모를 저장할 때 자식들도 일일이 저장해주어야 하는 번거로움이 있다.

#### **Cascade가 없을 때**

```java
// 부모와 자식 객체 생성
Parent parent = new Parent();
Child child1 = new Child();
Child child2 = new Child();

// 부모에 자식들 연관관계 설정
parent.addChild(child1);
parent.addChild(child2);

// 영속성 컨텍스트에 각각 저장해야 한다.
em.persist(parent);
em.persist(child1); // 자식1 수동 저장
em.persist(child2); // 자식2 수동 저장
```

#### **Cascade가 있을 때**

`Parent` 엔티티에 `cascade = CascadeType.PERSIST` 옵션을 추가한다. `PERSIST`는 '저장' 작업을 전이시키는 옵션이다.

```java
// Parent.java
@OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
private List<Child> children = new ArrayList<>();

// --- 비즈니스 로직 ---
Parent parent = new Parent();
Child child1 = new Child();
Child child2 = new Child();

parent.addChild(child1);
parent.addChild(child2);

// 부모만 저장하면 자식들까지 알아서 저장된다.
em.persist(parent); // 자식들도 함께 PERSIST 상태가 된다.
```

#### **주요 Cascade 타입**

- **`ALL`**: 모든 생명주기 이벤트(저장, 삭제, 병합 등)를 전이시킨다. 가장 강력하고 편리하지만, 그만큼 신중하게 사용해야 한다.
- **`PERSIST`**: 부모를 저장(`persist`)할 때, 자식도 함께 저장된다.
- **`REMOVE`**: 부모를 삭제(`remove`)할 때, 자식도 함께 삭제된다.
- **`MERGE`**: 준영속 상태의 부모를 병합(`merge`)할 때, 자식도 함께 병합된다.

**핵심 주의사항**: 영속성 전이는 부모가 자식의 생명주기를 **단독으로 소유**할 때만 사용해야 한다. 만약 자식 엔티티가 다른 곳에서도 참조되거나 독립적인 생명주기를 가질 수 있다면, `CascadeType.ALL`이나 `REMOVE`는 예상치 못한 데이터 삭제로 이어질 수 있다.

---

#### 고아 객체(Orphan Removal): 부모 없는 자식의 자동 청소

**고아 객체 제거**는 이름 그대로, 부모와의 연관관계가 끊어져 **'고아(Orphan)'** 가 된 자식 엔티티를 데이터베이스에서 **자동으로 삭제**하는 기능이다.

이 기능의 핵심은 **"부모의 컬렉션에서 제거되는 것만으로 삭제가 트리거된다"** 는 점이다.

```java
// Parent.java
@OneToMany(mappedBy = "parent", orphanRemoval = true) // 고아 객체 제거 옵션 활성화
private List<Child> children = new ArrayList<>();

// --- 비즈니스 로직 ---
// 1. 부모와 자식 조회
Parent parent = em.find(Parent.class, parentId);

// 2. 부모의 컬렉션에서 첫 번째 자식을 제거 (관계 단절)
parent.getChildren().remove(0);

// 3. 트랜잭션 커밋 시점!
// JPA는 parent의 children 컬렉션에 더 이상 없는 자식 객체를 '고아'로 인식하고
// 자동으로 DELETE 쿼리를 실행하여 DB에서 삭제한다.
```

`em.remove()`를 직접 호출하지 않았음에도 불구하고, 단지 부모의 컬렉션에서 빠졌다는 이유만으로 데이터베이스에서 삭제된다는 점이 매우 중요하다.

**핵심 주의사항**: 고아 객체 제거는 해당 자식이 **오직 하나의 부모에게만 소유(owned)** 될 때만 사용해야 한다. 만약 `parent1`의 컬렉션에서 제거된 `child`가 `parent2`의 컬렉션에도 속해 있다면, 이 기능은 의도치 않게 `child`를 삭제하여 데이터 무결성을 깨뜨릴 수 있다.

---

#### `CascadeType.REMOVE` vs. `orphanRemoval = true`: 결정적 차이

두 기능 모두 부모가 삭제될 때 자식이 삭제된다는 공통점이 있어 혼동하기 쉽지만, 작동하는 결정적인 순간이 다르다.

| 상황                                                                                   | `CascadeType.REMOVE`의 동작                                                             | `orphanRemoval = true`의 동작                                                                       |
| :------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------- |
| **`em.remove(parent)` 호출 시** <br/> (부모 엔티티 자체를 삭제)                        | **자식과 부모 모두 삭제 (DELETE)** <br/> 이유: `remove` 명령이 자식에게 연쇄 전파됨.    | **자식과 부모 모두 삭제 (DELETE)** <br/> 이유: 부모가 사라져 자식이 고아가 되므로 삭제됨.           |
| **`parent.getChildren().remove(child)` 호출 시** <br/> (부모의 컬렉션에서 자식을 제거) | **데이터베이스에 아무 변화 없음** <br/> 이유: `remove` 이벤트가 아니므로 감지하지 않음. | **컬렉션에서 제거된 자식만 삭제 (DELETE)** <br/> 이유: 부모와 연결이 끊겨 고아가 되었으므로 삭제됨. |

> - `CascadeType.REMOVE`: 오직 부모 엔티티 자체를 삭제(em.remove(parent))할 때만 연쇄적으로 자식을 삭제
> - `orphanRemoval=true`: 부모 컬렉션에서 자식을 제거(parent.getChildren().remove(child))할 때 자식을 삭제

---

#### 실무 가이드: 언제 무엇을 사용해야 하는가?

- **`CascadeType.PERSIST`**: 부모를 저장할 때 자식도 항상 함께 생성된다면, 주저 없이 사용해도 좋다. 상대적으로 안전하고 편리하다.

- **`cascade = CascadeType.ALL` + `orphanRemoval = true`**: 이 조합은 **부모가 자식의 생명주기를 100% 완벽하게 책임질 때** 사용한다. 자식은 부모 없이는 존재 의미가 없는, 매우 강한 소유 관계일 때 적합하다.

  - **좋은 예시**: `Order`(주문)와 `OrderItem`(주문항목), `Post`(게시물)와 `Comment`(댓글). `OrderItem`은 `Order` 없이는 의미가 없고, `Comment` 역시 `Post`가 삭제되면 함께 사라져야 한다. 이런 관계가 바로 DDD의 **애그리거트 루트(Aggregate Root)** 개념을 구현하는 좋은 예이다.
