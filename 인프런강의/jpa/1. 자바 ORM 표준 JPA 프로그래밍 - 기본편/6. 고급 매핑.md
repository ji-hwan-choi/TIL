## JPA 고급 매핑: 상속 관계와 공통 속성 관리

객체지향 프로그래밍의 핵심 특징 중 하나인 **상속**은 코드의 재사용성을 높이고 논리적인 모델을 가능하게 한다.  
하지만 데이터를 영구적으로 저장하는 관계형 데이터베이스에는 상속이라는 개념이 존재하지 않는다.  
이처럼 서로 다른 패러다임 간의 불일치를 해결하고, 객체의 상속 구조를 데이터베이스에 자연스럽게 연결하는 것이 바로 ORM(Object-Relational Mapping)의 핵심 과제 중 하나이며, JPA는 이를 위한 효과적인 매핑 전략들을 제공한다.

---

## 1. 상속 관계 매핑 (Inheritance Mapping)

상속 관계 매핑은 슈퍼타입-서브타입으로 표현되는 객체 모델을 데이터베이스 테이블 구조로 변환하는 기술이다. 예를 들어, `상품(Item)`이라는 공통 개념을 `음반(Album)`, `영화(Movie)`, `책(Book)`이 구체화하는 객체 상속 구조를 데이터베이스에 어떻게 저장할지 결정하는 것이다.

JPA에서는 `@Inheritance` 어노테이션의 `strategy` 속성을 통해 다음 세 가지 전략 중 하나를 선택할 수 있다.

- `InheritanceType.JOINED`: 조인 전략
- `InheritanceType.SINGLE_TABLE`: 단일 테이블 전략
- `InheritanceType.TABLE_PER_CLASS`: 구현 클래스마다 테이블 전략

어떤 전략을 선택하는지에 따라 데이터베이스의 테이블 구조, 성능, 데이터 무결성 측면에서 장단점이 명확하게 갈리므로 신중한 선택이 필요하다.

### **1) 조인 전략 (Joined Strategy)**

가장 표준적이고 정규화 원칙에 부합하는 전략이다. 부모 객체의 공통 속성은 부모 테이블에, 자식 객체 각각의 고유 속성은 별도의 자식 테이블에 저장하고, 부모-자식 테이블의 관계는 기본 키(PK)와 외래 키(FK)를 통해 맺는다.

#### **주요 어노테이션 및 코드 예제**

부모 클래스에 `@Inheritance(strategy = InheritanceType.JOINED)`를 명시한다. 자식 클래스는 부모 클래스를 확장하기만 하면 된다.

```java
// 부모 엔티티
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "DTYPE") // 자식 테이블을 구분하는 컬럼 (필수는 아님)
public abstract class Item {
    @Id @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}

// 자식 엔티티 1
@Entity
@DiscriminatorValue("A") // 구분 컬럼에 저장될 값
public class Album extends Item {
    private String artist;
}

// 자식 엔티티 2
@Entity
@DiscriminatorValue("M")
public class Movie extends Item {
    private String director;
    private String actor;
}

// 자식 엔티티 3
@Entity
@DiscriminatorValue("B")
public class Book extends Item {
    private String author;
    private String isbn;
}
```

- `@DiscriminatorColumn`: 부모 테이블에 어떤 자식 엔티티와 관련있는지를 나타내는 구분 컬럼(`DTYPE`)을 생성한다. 조인 전략에서는 필수는 아니지만, 어떤 자식 데이터인지 명확히 알 수 있어 유지보수에 유리하다.
- `@DiscriminatorValue`: `DTYPE` 컬럼에 저장될 값을 지정한다. **지정하지 않으면 기본적으로 클래스 이름이 저장**된다.

#### **생성되는 테이블 구조**

```sql
CREATE TABLE ITEM (
    ITEM_ID BIGINT NOT NULL,
    NAME VARCHAR(255),
    PRICE INTEGER NOT NULL,
    DTYPE VARCHAR(31), -- @DiscriminatorColumn
    PRIMARY KEY (ITEM_ID)
);

CREATE TABLE ALBUM (
    ITEM_ID BIGINT NOT NULL,
    ARTIST VARCHAR(255),
    PRIMARY KEY (ITEM_ID),
    FOREIGN KEY (ITEM_ID) REFERENCES ITEM (ITEM_ID)
);

CREATE TABLE MOVIE (
    ITEM_ID BIGINT NOT NULL,
    DIRECTOR VARCHAR(255),
    ACTOR VARCHAR(255),
    PRIMARY KEY (ITEM_ID),
    FOREIGN KEY (ITEM_ID) REFERENCES ITEM (ITEM_ID)
);

-- BOOK 테이블도 유사하게 생성
```

#### **장점과 단점**

- **장점**

  - **테이블 정규화**: 데이터가 중복 없이 저장된다.
  - **저장 공간 효율화**: 각 자식의 고유 속성은 해당 테이블에만 저장되므로 공간 낭비가 없다.
  - **외래 키 참조 무결성**: 외래 키 제약조건을 사용하여 데이터의 일관성을 유지할 수 있다.

- **단점**

  - **조회 성능**: 자식 엔티티 조회 시 항상 부모 테이블과 조인이 발생하므로 성능이 상대적으로 느릴 수 있다.
  - **복잡한 조회 쿼리**: 생성되는 SQL이 복잡하다.
  - **데이터 등록의 번거로움**: 자식 엔티티 하나를 저장할 때 `INSERT` SQL이 부모와 자식 테이블에 각각 한 번씩, 총 두 번 실행된다.

---

### **2) 단일 테이블 전략 (Single-Table Strategy)**

상속 계층의 모든 클래스 정보를 하나의 테이블에 통합하여 저장하는 전략이다. JPA 구현체의 기본 상속 전략이기도 하다. 어떤 종류의 자식 데이터인지 구분하기 위해 `DTYPE`과 같은 구분 컬럼을 **반드시** 사용해야 한다.

#### **주요 어노테이션 및 코드 예제**

`strategy`를 `InheritanceType.SINGLE_TABLE`로 변경하는 것 외에는 조인 전략과 코드가 거의 동일하다.

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE") // 단일 테이블 전략에서는 필수
public abstract class Item {
    @Id @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}

// Album, Movie, Book 엔티티는 조인 전략 예제와 동일
@Entity @DiscriminatorValue("A") public class Album extends Item { ... }
@Entity @DiscriminatorValue("M") public class Movie extends Item { ... }
@Entity @DiscriminatorValue("B") public class Book extends Item { ... }
```

#### **생성되는 테이블 구조**

모든 속성이 하나의 `ITEM` 테이블에 통합된다.

```sql
CREATE TABLE ITEM (
    DTYPE VARCHAR(31) NOT NULL, -- 구분 컬럼이 맨 앞에 위치하는 경우가 많음
    ITEM_ID BIGINT NOT NULL,
    NAME VARCHAR(255),
    PRICE INTEGER NOT NULL,
    ARTIST VARCHAR(255),    -- Album 속성
    DIRECTOR VARCHAR(255),  -- Movie 속성
    ACTOR VARCHAR(255),     -- Movie 속성
    AUTHOR VARCHAR(255),    -- Book 속성
    ISBN VARCHAR(255),      -- Book 속성
    PRIMARY KEY (ITEM_ID)
);
```

#### **장점과 단점**

- **장점**

  - **빠른 조회 성능**: 조인이 필요 없으므로 조회 성능이 일반적으로 가장 빠르다.
  - **단순한 조회 쿼리**: `SELECT` 쿼리가 매우 단순하다.

- **단점**

  - **컬럼의 `NULL` 허용**: 특정 자식에만 해당하는 속성들은 다른 자식 타입의 데이터가 저장될 때 `NULL`이 된다. 따라서 모든 자식 속성 컬럼은 `NOT NULL` 제약조건을 걸 수 없다.
  - **테이블 비대화**: 상속 구조가 복잡하고 자식 타입이 많아지면 하나의 테이블에 너무 많은 컬럼이 생겨 거대해진다. 이는 특정 상황에서 오히려 데이터베이스 성능 저하의 원인이 될 수 있다.

---

### **3) 구현 클래스마다 테이블 전략 (Table-per-Class Strategy)**

(실무에서 사용하지 않는걸 권장)

자식 클래스마다 독립된 테이블을 생성하는 전략이다. 부모에게서 상속받은 속성들까지 모두 포함하여 각 자식 테이블이 완전한 형태로 만들어진다.

#### **주요 어노테이션 및 코드 예제**

`strategy`를 `InheritanceType.TABLE_PER_CLASS`로 변경한다. 이 전략에서는 부모 클래스를 `abstract`로 선언하는 것이 좋다. 부모 클래스만의 테이블은 생성되지 않기 때문이다.

```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Item { // 부모는 테이블이 생성되지 않으므로 abstract 권장
    @Id @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}

// Album, Movie, Book 엔티티는 부모를 상속받는 것 외에는 특별한 어노테이션 불필요
@Entity public class Album extends Item { ... }
@Entity public class Movie extends Item { ... }
@Entity public class Book extends Item { ... }
```

- 이 전략에서는 `@DiscriminatorColumn`을 사용할 수 없다.

#### **생성되는 테이블 구조**

각 자식 엔티티에 해당하는 테이블이 각각 생성되며, 부모의 속성까지 모두 가진다.

```sql
CREATE TABLE ALBUM (
    ITEM_ID BIGINT NOT NULL,
    NAME VARCHAR(255),    -- 부모 속성
    PRICE INTEGER NOT NULL, -- 부모 속성
    ARTIST VARCHAR(255),
    PRIMARY KEY (ITEM_ID)
);

CREATE TABLE MOVIE (
    ITEM_ID BIGINT NOT NULL,
    NAME VARCHAR(255),    -- 부모 속성
    PRICE INTEGER NOT NULL, -- 부모 속성
    DIRECTOR VARCHAR(255),
    ACTOR VARCHAR(255),
    PRIMARY KEY (ITEM_ID)
);

-- BOOK 테이블도 유사하게 생성
```

#### **장점과 단점**

- **장점**

  - **서브타입의 명확한 구분**: 자식 테이블들이 완전히 분리되어 있어 특정 서브타입을 다루기 편리하다.
  - **`NOT NULL` 제약조건 활용**: 각 테이블별로 `NOT NULL` 제약조건을 자유롭게 사용할 수 있다.

- **단점**

  - **느린 통합 조회 성능**: 부모 타입으로 모든 자식 데이터를 조회(`em.find(Item.class, ...)`)하면, 모든 자식 테이블을 `UNION`으로 묶어 검색하는 복잡한 SQL이 생성되어 성능이 매우 느리다.
  - **복잡한 키 관리**: 자식 테이블들의 기본 키 값을 전체적으로 일관성 있게 관리하기가 까다롭다.
  - **비추천 전략**: 위와 같은 명확한 단점들 때문에 데이터베이스 설계자와 ORM 전문가 모두 추천하지 않는 전략이다.

---

## 2. @MappedSuperclass: 공통 매핑 정보 상속

`@MappedSuperclass`는 상속 관계 매핑과는 다른 개념이다. 이는 엔티티들이 공통으로 사용하는 매핑 정보(필드)를 담는 **"속성 전용 슈퍼클래스"** 를 정의할 때 사용한다. 이 클래스는 테이블과 매핑되지 않으며, 단지 자식 엔티티에게 자신의 매핑 정보를 물려주는 역할을 한다.

주로 `생성일`, `수정일`, `생성자`와 같이 대부분의 엔티티가 공통적으로 가져야 하는 감사(Audit) 정보나 공통 식별자를 관리할 때 매우 유용하다.

#### **핵심 특징**

- 테이블과 매핑되지 않고, 자식 클래스에 매핑 정보만 제공한다.
- 엔티티가 아니므로, `em.find()`나 JPQL을 사용하여 직접 조회할 수 없다.
- 이 클래스를 직접 생성하여 사용할 일이 거의 없으므로 **추상 클래스(abstract class)** 로 만드는 것을 강력히 권장한다.

#### **코드 예제**

모든 엔티티가 공통으로 가질 `createdAt`, `updatedAt` 필드를 `BaseEntity`로 정의한다.

```java
// 공통 속성을 담은 슈퍼클래스
@MappedSuperclass
public abstract class BaseEntity {

    @Column(name = "CREATED_AT")
    private LocalDateTime createdAt;

    @Column(name = "UPDATED_AT")
    private LocalDateTime updatedAt;

    // Getter, Setter ...
}

// BaseEntity를 상속받는 Member 엔티티
@Entity
public class Member extends BaseEntity {

    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    private String name;

    // ...
}

// BaseEntity를 상속받는 Order 엔티티
@Entity
@Table(name = "ORDERS")
public class Order extends BaseEntity {

    @Id @GeneratedValue
    @Column(name = "ORDER_ID")
    private Long id;

    // ...
}
```

#### **생성되는 테이블 구조**

`BaseEntity` 자체의 테이블은 생성되지 않는다. 대신, 이를 상속받는 `Member`와 `Order` 엔티티의 테이블에 `BaseEntity`의 필드들이 컬럼으로 포함된다.

```sql
CREATE TABLE MEMBER (
    MEMBER_ID BIGINT NOT NULL,
    NAME VARCHAR(255),
    CREATED_AT TIMESTAMP, -- BaseEntity로부터 상속
    UPDATED_AT TIMESTAMP, -- BaseEntity로부터 상속
    PRIMARY KEY (MEMBER_ID)
);

CREATE TABLE ORDERS (
    ORDER_ID BIGINT NOT NULL,
    CREATED_AT TIMESTAMP, -- BaseEntity로부터 상속
    UPDATED_AT TIMESTAMP, -- BaseEntity로부터 상속
    PRIMARY KEY (ORDER_ID)
);
```

이처럼 `@MappedSuperclass`를 사용하면 여러 테이블에 반복적으로 나타나는 컬럼들을 하나의 클래스에서 통합 관리하여 코드의 중복을 제거하고 객체지향적인 설계를 유지할 수 있다.
