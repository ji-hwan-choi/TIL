### **연관관계 매핑 시 고려사항**

JPA에서 엔티티 간의 연관관계를 매핑할 때는 다음 세 가지를 핵심적으로 고려해야 한다.

- **다중성**: 관계에 참여하는 객체의 수를 나타낸다. 예를 들어, 여러 멤버(N)가 하나의 팀(1)에 속하는 다대일(N:1) 관계가 있다. `@ManyToOne`, `@OneToMany`, `@OneToOne`, `@ManyToMany` 어노테이션을 사용하여 표현한다.
- **방향성**: 객체 참조의 방향을 의미한다. 한쪽 객체만 다른 객체를 참조하면 **단방향** 관계이고, 양쪽 객체가 서로를 참조하면 **양방향** 관계이다. 테이블은 외래 키(Foreign Key) 하나로 양방향 조인이 가능하므로 방향의 개념이 없다.
- **연관관계의 주인(Owner)**: 양방향 관계에서 외래 키를 관리하는 쪽을 지정하는 개념이다. 테이블은 외래 키 하나로 관계가 관리되지만, 객체는 양쪽에서 서로를 참조하므로 두 참조 중 하나를 정해 외래 키를 관리하도록 해야 한다. 연관관계의 주인만이 외래 키를 등록하고 수정할 수 있으며, 주인이 아닌 쪽은 오직 조회만 가능하다.

---

### **다대일 (N:1)**

다대일 관계는 실무에서 가장 많이 사용하는 연관관계이다. 여러 개의 `Member` 엔티티가 하나의 `Team` 엔티티에 속하는 경우가 대표적이다.

- **단방향 매핑**: `Member` 엔티티에서만 `Team` 엔티티를 참조하는 경우이다. MEMBER 테이블에 TEAM_ID 외래 키가 존재한다.
- **양방향 매핑**: `Member`와 `Team` 엔티티가 서로를 참조하는 관계이다. `Team` 엔티티에는 자신에게 속한 멤버들의 목록(List)이 추가된다. 이 경우 외래 키가 있는 쪽, 즉 `Member` 엔티티가 연관관계의 주인이 된다. 주인이 아닌 `Team` 엔티티의 members 필드는 조회를 위한 용도로만 사용된다.

**코드 예시 (양방향)**

`Member`는 연관관계의 주인으로서 `Team`을 참조하고, `Team`은 자신에게 속한 `Member` 목록을 가진다.

```java
// Member.java - 연관관계의 주인 (N쪽)
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;

    private String username;

    @ManyToOne // 다대일 관계 명시
    @JoinColumn(name = "TEAM_ID") // 매핑할 외래 키 이름 지정
    private Team team;
}
```

```java
// Team.java - 주인이 아님 (1쪽)
@Entity
public class Team {
    @Id @GeneratedValue
    private Long id;

    private String name;

    // mappedBy: 'Member' 엔티티의 'team' 필드에 의해 관리된다는 의미
    // 주인이 아니므로 외래 키에 영향을 주지 않고, 조회만 가능
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
}
```

---

### **일대다 (1:N)**

하나의 `Team` 엔티티가 여러 `Member` 엔티티를 참조하는 관계이다.

- **단방향 매핑**: 'Team' 엔티티만 'Member' 엔티티 목록을 참조하는 구조이다. 이 경우 연관관계의 주인은 'Team'(1)이 되는데, 실제 외래 키는 'MEMBER' 테이블(N)에 존재한다. 객체와 테이블 간의 이런 불일치 때문에, 'Team'이 외래 키를 관리하기 위해 추가적인 UPDATE SQL 쿼리가 실행되는 단점이 있다. 따라서 이 방식은 추천되지 않는다. `@JoinColumn` 어노테이션을 사용하지 않으면 중간에 별도의 조인 테이블을 만드는 방식이 사용될 수 있다.
- **양방향 매핑**: 공식적으로 존재하는 매핑은 아니지만, 읽기 전용 필드를 사용하여 양방향처럼 구현하는 방법이 있다. 하지만 구조가 복잡해지므로 **일대다 관계는 다대일 양방향 매핑을 사용하는 것이 좋다.** 즉, 'Member'(N)를 연관관계의 주인으로 설정하여 관리하는 것이 효율적이다.

---

### **일대일 (1:1)**

하나의 엔티티가 다른 엔티티와 하나씩만 매핑되는 관계이다. 외래 키는 주 테이블 또는 대상 테이블 중 하나를 선택하여 둘 수 있으며, 해당 외래 키에는 유니크(UNIQUE) 제약 조건을 추가해야 한다.

- **주 테이블에 외래 키를 두는 경우**: 객체지향 개발자들이 선호하는 방식으로, JPA 매핑이 편리하다. 주 테이블만 조회해도 대상 테이블의 데이터 존재 여부를 확인할 수 있는 장점이 있다. 하지만 외래 키에 `null` 값을 허용해야 하는 단점이 있다. 다대일 매핑과 유사하게 처리된다.
- **대상 테이블에 외래 키를 두는 경우**: 데이터베이스 개발자들이 선호하는 방식이다. 향후 관계가 1:N으로 변경될 때 테이블 구조를 유지할 수 있는 장점이 있다. 하지만 JPA에서 프록시 기능에 한계가 있어 지연 로딩(Lazy Loading)을 설정해도 항상 즉시 로딩(Eager Loading)이 발생하는 단점이 있다.
- **연관관계의 주인**: 외래 키가 있는 곳이 연관관계의 주인이 된다.

**코드 예시 (주 테이블에 외래 키가 있는 양방향)**

`Member`가 연관관계의 주인으로서 `Locker`를 가지는 상황이다.

```java
// Member.java - 연관관계의 주인
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;

    private String username;

    @OneToOne // 일대일 관계 명시
    @JoinColumn(name = "LOCKER_ID") // MEMBER 테이블에 생성될 외래 키
    private Locker locker;
}
```

```java
// Locker.java - 주인이 아님
@Entity
public class Locker {
    @Id @GeneratedValue
    private Long id;

    private String name;

    @OneToOne(mappedBy = "locker") // 'Member' 엔티티의 'locker' 필드에 의해 관리됨
    private Member member;
}
```

---

### **다대다 (N:M)**

회원과 상품처럼, 하나의 회원이 여러 상품을 주문하고 하나의 상품이 여러 회원에게 주문될 수 있는 관계이다.

- **관계형 데이터베이스의 한계**: 데이터베이스에서는 정규화 원칙에 따라 두 테이블만으로 다대다 관계를 표현할 수 없다. 따라서 'MEMBER_PRODUCT'와 같은 중간 연결 테이블을 만들어 두 개의 일대다 관계로 풀어내야 한다.
- **객체와 `@ManyToMany`**: 객체는 컬렉션을 사용하여 다대다 관계를 표현할 수 있으며, JPA는 `@ManyToMany` 어노테이션을 제공한다. `@JoinTable`을 통해 연결 테이블을 지정할 수 있다.
- **실무에서의 한계와 대안**: `@ManyToMany`는 편리해 보이지만 실무에서는 거의 사용되지 않는다. 왜냐하면 연결 테이블이 단순히 두 테이블을 연결하는 역할만 하지 않고, 주문 수량이나 주문 날짜와 같은 추가적인 데이터를 포함하는 경우가 많기 때문이다. `@ManyToMany`는 이러한 추가 필드를 매핑할 수 없다.
- **해결책**: 이 문제를 해결하기 위해, **연결 테이블을 별도의 엔티티로 승격**시킨다. 예를 들어, `Order`라는 엔티티를 만들고 `Member`와는 N:1, `Product`와는 1:N 관계를 맺도록 설계를 변경한다. 이렇게 하면 다대다 관계를 보다 유연하고 확장성 있게 관리할 수 있다.

```java
// MemberProduct.java - 연결 엔티티
@Entity
@Table(name = "ORDERS")
public class MemberProduct {
    @Id @GeneratedValue
    @Column(name = "ORDER_ID")
    private Long id;

    @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;

    @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    private Product product;

    private int orderAmount; // 추가 속성
    private LocalDateTime orderDate; // 추가 속성
}
```

```java
// Member.java
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;
    private String username;

    @OneToMany(mappedBy = "member")
    private List<MemberProduct> memberProducts = new ArrayList<>();
}
```

```java
// Product.java
@Entity
public class Product {
    @Id @GeneratedValue
    @Column(name = "PRODUCT_ID")
    private Long id;
    private String name;

    // Product에서 MemberProduct를 참조할 필요가 있다면 양방향으로 설정
    @OneToMany(mappedBy = "product")
    private List<MemberProduct> memberProducts = new ArrayList<>();
}
```

---

### 정리

- 연관관계의 주인만이 외래 키를 등록하고 수정할 수 있다. 주인이 아닌 쪽은 읽기 기능만 가능.
- 다대일 매핑은 데이터베이스의 외래 키 위치와 객체의 참조 방향이 자연스럽게 일치하여 권장된다. 특히 양방향 다대일이 유용하다.
- '1' 쪽이 연관관계 주인이 되어 'N' 쪽 컬렉션을 매핑하는 단방향 일대다(1:N) 관계에서 주로 발생하는 데이터베이스 관련 이슈는 외래 키가 'N' 쪽에 있어 '1' 쪽 엔티티를 저장/수정할 때 'N' 테이블의 외래 키를 업데이트하는 추가 쿼리가 발생한다.
- 일대일 관계는 각 엔티티가 서로에게 하나만 연결됨을 의미하며, 이는 외래 키에 Unique 제약 조건을 설정하여 구현해야 한다.
- @ManyToMany는 조인 테이블에 단순히 연결 정보 외 다른 데이터를 추가하기 어렵다. 중간 테이블을 별도 엔티티로 만들어 해결해야 한다.
