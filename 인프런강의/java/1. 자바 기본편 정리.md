- **멤버 변수(필드)는 자동으로 초기화** 되지만, 지역 변수는 꼭 수동으로 초기화를 해줘야 한다.

- 절차 지향은 데이터와 기능이 분리된 채 순서대로 실행되지만, **객체 지향은 데이터와 기능이 하나의 객체로 묶여 관리됩니다. 이것이 큰 차이점이다.**

- 객체가 가져야 할 **데이터와 기능들을** 하나의 단위(클래스)로 묶고, **내부 구현을 외부에 숨기는 것을 캡슐화**라고 부른다. (OOP의 기본 원칙)
  캡슐화는 **데이터를 외부에서 직접 접근하지 못하게 숨기고, 데이터를 다루는 기능만 공개하는 것이 핵심**이에요. 데이터 보호가 주 목적입니다.

- 현실 세계의 모든 것은 속성과 기능으로 설명할 수 있듯, 프로그래밍 객체도 해당 객체의 상태를 나타내는 <strong>데이터(속성)</strong>와 객체가 수행할 수 있는 <strong>동작(기능)</strong>으로 구성됩니다.

- 생성자 안에서 `this()` 는 다른 생성자 호출하는건데, 생성자의 첫번째줄에서만 사용 가능하다.

- `import a.*` 을 한다고 가정하면, `a.b.c` 패키지 까지 다 `import` 되는게 아니라, `a` 밑에있는 클래스만 `import` 되는것이다.

- **클래스에는 `public`과 `default` 접근 제어자만 사용 가능**해요. `private`나 `protected`는 클래스 레벨에 사용할 수 없다.

#### JVM 메모리 영역

1.  메서드 영역

    - JVM이 클래스를 로딩할 때 해당 클래스의 <strong>정의 정보(이름, 메서드, 필드, 상수 등)</strong>를 저장하는 공간이다.
      | 항목 | 설명 |
      |---------------------|--------------------------------------------------|
      | 클래스 이름 | 클래스의 완전한 이름(패키지 포함) |
      | 부모 클래스 이름 | 상속 계층 정보 |
      | 메서드 정보 | 메서드의 이름, 반환 타입, 매개변수 등 |
      | 필드 정보 | 클래스 변수(`static` 변수) 포함 |
      | 상수 풀(Constant Pool) | 리터럴(literal)과 심볼(Symbol) 정보 등 |
      | 접근 제어자 정보 | `public`, `private` 등 클래스, 메서

2.  콜 스택

    - 스택 영역은 메서드가 호출될 때마다 <strong>스택 프레임이 생성</strong>되고, 해당 메서드의 <strong>지역변수, 매개변수, 중간 계산값</strong> 등이 저장된다.  
      메서드 실행이 끝나면 <strong>스택 프레임은 제거된다.</strong>

3.  힙 영역
    - `new` 키워드를 통해 생성된 <strong>객체(인스턴스)가 저장되는 공간</strong>으로, 해당 객체 내부의 <strong>인스턴스 변수 값들도 함께 저장된다.</strong>
      객체는 개발자가 더 이상 참조하지 않으면 GC(Garbage Collector)에 의해 정리된다.

<br>

> 스택 영역은 더 정확히는 각 **쓰레드별로 하나의 실행 스택이 생성**된다. 따라서 쓰레드 수 만큼 스택 영역이 생성된다.  
> **지역변수** : 콜 스텍 -> 스택 프레임에 존재  
> **인스턴스 변수** : 힙 영역에 존재  
> **클래스 변수(static)** : 메서드 영역에 존재

---

<br>

- **`static` 메서드는 `static` 변수(클래스 변수)와 `static` 메서드만 접근 가능**하다. 인스턴스 변수, 인스턴스 메서드는 접근 불가능한다.

- `int final value;` 로 정의하는건 **어차피 변하지 않은 값을 객체 생성마다 메모리에 저장하므로 메모리 낭비**이다. **`final` 키워드를 사용할거면 `static final`로 정의하는게 더 좋은 선택**이다.

- `final Data data = new Data();` 와 같이 정의하면 data 에 새로운 객체로 변경은 못하지만 `data.value` 등 객체의 인스턴스 변수 등은 변경이 가능하다.

- 다중 상속을 허용한다면 어떤 부모의 메서드를 호출 해야 될지(각 부모의 메서드명이 같을때) 모호해 진다. (다이아몬드 문제)

- 상속 관계(자식)의 객체를 생성하면 부모 클래스의 생성자가 먼저 실행되며, **부모와 자식의 필드와 메서드가 모두 포함된 객체가 생성**됩니다.  
  상속 관계의 객체를 사용하여 메서드를 호출할 때, **호출자의 타입(클래스)을 통해 대상 타입을 찾는다.**  
  현재 타입에서 메서드를 찾지 못하면 상위 부모 타입으로 메서드를 찾아서 실행한다. 기능을 찾지 못하면 컴파일 오류가 발생한다.

- 자식 클래스의 생성자에서 `super()`는 **부모 클래스의 생성자를 호출할 때 사용**되며, 반드시 **생성자의 첫 줄에만** 위치할 수 있다.

- `super()`는 명시하지 않으면 기본적으로 **컴파일러가 자동으로 추가**하지만, 부모 클래스에 기본 생성자가 없는 경우에는 반드시 `super(...)`를 통해 부모 생성자의 매개변수 규칙에 맞춰 직접 호출해야 한다.  
  한 생성자 내에서 `this(...)`와 `super(...)`를 동시에 사용할 수는 없으며, `this(...)`가 호출되면 그 생성자 안에서 결국 다시 `super(...)`가 호출되어야 한다.  
   즉, 어떤 생성자든 부모 생성자가 반드시 한 번 호출되도록 설계되어 있다.

- **final이 클래스에 붙으면 상속이 불가능**한 클래스이다.

- **final이 메서드에 붙으면 오버라이드 불가능**하다.

- 메서드 호출 시 자바는 컴파일 시점에 참조 변수의 타입을 기준으로 메서드의 존재 여부를 확인니다.  
  존재한다면, 런타임 시점에는 실제 객체 타입에서 **오버라이딩된 메서드를 먼저 찾아 실행**하고, 없으면 부모 클래스의 메서드를 실행한다.

  - 자바에서 메서드 호출 가능 여부는 **“참조 변수의 타입”** 을 기준으로 컴파일 시 결정된다.  
    실행 시점에는 “실제 객체” 기준으로 오버라이딩된 메서드만 동적으로 결정된다.

- 자바에서 자식 클래스의 객체가 생성될 때, **객체 내부에는 부모 클래스의 필드와 메서드도 함께 포함**된다.  
  이 부모 클래스의 부분을 올바르게 초기화하기 위해, 자식 클래스 생성자에서는 `super()`를 사용해 부모 클래스의 생성자를 호출한다.

- 다형성은 객체 지향의 중요한 특징으로, 하나의 객체가 여러 가지 타입으로 취급될 수 있음을 의미한다. 이는 코드의 유연성과 확장성을 높여준다.

- 부모 타입 변수는 선언된 타입(부모)의 멤버만 알고 있기 때문에, **실제 참조하는 인스턴스가 자식이더라도 부모 클래스에 정의된 멤버만 직접 호출 가능**하다. 자식 고유 멤버는 다운캐스팅이 필요.

  - 부모 변수는 자식 고유의 멤버를 직접 알지 못한다. 따라서 부모 타입 변수가 참조하는 자식 인스턴스의 고유 기능을 사용하려면 다운캐스팅을 통해 자식 타입으로 형변환해야 한다.

- 다형성 환경에서 메소드가 오버라이딩되면 변수의 타입이 아닌 실제 인스턴스의 타입에 따라 실행될 메소드가 결정된다. **오버라이딩된 자식 메소드가 항상 우선권**을 가진다.

> 부모 타입의 참조 변수가 자식 객체를 가리키고 있고, 부모 클래스와 자식 클래스에 동일한 이름의 인스턴스 변수 a가 각각 정의되어 있을 경우, a를 참조하면 **부모 클래스의 a 값이 출력된다.**  
> 반면, 부모와 자식 클래스에 동일한 이름의 메서드가 정의되어 있다면, 이는 오버라이딩으로 간주되며, **자식 클래스에서 오버라이딩된 메서드가 우선적으로 실행**된다.
> 이 현상은 **변수는 컴파일 타임 타입 기준으로 바인딩**되기 때문이다.
> 반면, **메서드는 런타임 실제 객체 기준으로 호출**된다.

- **추상 클래스**는 '미완성된' 클래스로, 구체적인 객체 생성이 목적이 아니기에 **`new`로 인스턴스화할 수 없다. 상속받아 완성해야 한다.**

- **인터페이스에서 멤버 변수는 `public`, `static`, `final` 이 모두 포함 된다고 간주**한다.(생략가능) 즉, 상수로 간주한다. 하여 변수는 대문자와 언더바로 정의한다.

- 인터페이스는 여러군데에서 사용할 목적으로 사용하기 때문에, **접근제어자는 기본적으로 public** 이다. (메서드의 기본 접근 제어자는 `public`, 생략하면 `public`이다.)

- 인터페이스는 모든 메서드가 추상 메서드이므로, 이를 구현하는 **클래스에 반드시 구현하도록 강제하는 명확한 규약을 제공**한다. 이는 개발자 간의 계약을 명확히 하고, 실수나 오용을 방지하는 데 효과적이다.  
  또한 자바에서 클래스는 하나만 상속할 수 있지만, **인터페이스는 다중 구현이 가능해 다양한 역할**을 유연하게 조합할 수 있다.  
  반면 **추상 클래스는 일반 메서드가 추가되면 순수 추상성이 깨지고, 다중 상속이 불가능해 설계 확장성 측면에서 불리**하다. (초기엔 추상메서드만 뒀지만, 추후에 누군가가 일반 메서드를 추가 할 수 있다.)

  > 자바에서 클래스의 다중 상속을 허용하지 않는 이유는 다이아몬드 문제로 인한 메서드 상속의 모호성 때문이다.  
  > 두 개 이상의 부모 클래스에 동일한 이름의 메서드가 존재할 경우, 자식 클래스가 어떤 메서드를 상속받아야 하는지 판단하기 어려워진다.  
  > 반면, 여러 인터페이스를 구현하더라도, 동일한 이름의 메서드가 있다고 해도 **실제로는 구현 내용이 없기 때문에 충돌이 발생하지 않는다.**  
  > Java 8 이후 default 메서드가 도입 되었더라도, 충돌이 발생할 경우 구현 클래스에서 명시적으로 오버라이드하여 해결할 수 있도록 설계되어 있다. 따라서 자바는 클래스의 다중 상속은 금지하고, 인터페이스의 다중 구현은 허용한다.  
  > (인터페이스는 추상 메서드만 있어 호출 시 어떤 부모의 코드를 쓸지 모호한 '다이아몬드 문제'가 발생하지 않는다. 자식에서 무조건 구현하기 때문)

- 의존이란 어떤 클래스가 다른 클래스를 알고있다는걸 말한다. 객체지향에선 강한 의존은 좋지 않다.

  - 이를 해결하기 위해 의존을 줄이고 느슨하게 만들려고 인터페이스를 두고, 그걸 주입받는 방식(DI: 의존성 주입)을 사용한다.

- 클라이언트가 구체 클래스가 아닌 역할(인터페이스)에 의존할 때, 클라이언트 코드는 변경 없이 다양한 구현체를 받아들여 실행할 수 있다. 이는 개방-폐쇄 원칙(OCP)을 따르는 설계의 핵심.

  - OCP에서 '폐쇄'는 기능 확장을 위해 기존 코드를 수정하는 것을 최소화해야 함을 뜻합니다. 특히, 기능을 사용하는 핵심 클라이언트 코드는 변경되지 않아야 합니다.

- 다형성의 핵심은 동일한 인터페이스 변수가 런타임에 어떤 구현 객체를 참조하느냐에 따라 다른 동작을 한다는 것이다. 이를 통해 클라이언트는 변경 없이 다양한 서버 구현과 상호작용할 수 있습니다.

- 다형성은 인터페이스나 부모 클래스를 기반으로, 여러 가지 형태의 객체를 동일한 방식으로 다룰 수 있는 특성이다.  
  즉, 같은 메서드 호출이라도 실제로는 다른 동작을 수행하게 하여, 코드의 확장성과 유연성을 높일 수 있습니다.

- <strong>객체지향(Object-Oriented Programming, OOP)</strong>은 현실 세계를 객체(사물) 중심으로 모델링하여, 객체 간의 협력으로 프로그램을 구성하는 방법론이다.  
  객체지향의 특징으로, 상속, 다형성, 캡슐화, 추상화가 있다.
